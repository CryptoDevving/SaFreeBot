package eth

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"log"
	"math"
	"math/big"
	"net/http"
	"reflect"
	"regexp"
	"runtime"
	"sync"

	"strconv"
	"strings"
	"time"

	erc20 "Safu/contracts"
	pancakefactory "Safu/contracts"
	pancakepair "Safu/contracts"
	pancakerouter "Safu/contracts"
	"Safu/eth/solidityparser"
	rateLimiter "Safu/rate"

	"github.com/antlr/antlr4/runtime/Go/antlr/v4"
	"github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/hexutil"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/ethereum/go-ethereum/ethclient"
	"github.com/ethereum/go-ethereum/rpc"
)

type EthLib struct {
	ctx      context.Context
	RPCBSC   string
	RPCETH   string
	Mnemonic string
	ByteCode string
}

var clientBsc ethclient.Client
var clientEth ethclient.Client
var clientLocal ethclient.Client
var serverStarted bool
var slotz int
var bytestore int
var slotfilled int
var staticArray int
var preVarable string
var limter rateLimiter.RateLimiter

func InitEthlib(ctx context.Context, RPC_bsc string, RPC_eth string, mnemonics string) EthLib {
	limter = *rateLimiter.NewRateLimiter(time.Second, int(4))
	e := EthLib{ctx: ctx, RPCBSC: RPC_bsc, RPCETH: RPC_eth, Mnemonic: mnemonics, ByteCode: "0x6080604052600436106100385760003560e01c806306fdde03146100445780634658fc421461006f57806363336f4f146100a05761003f565b3661003f57005b600080fd5b34801561005057600080fd5b506100596100d1565b60405161006691906128ef565b60405180910390f35b61008960048036038101906100849190612aee565b61015f565b604051610097929190612ba6565b60405180910390f35b6100ba60048036038101906100b59190612bcf565b6115a9565b6040516100c8929190612ba6565b60405180910390f35b600080546100de90612c95565b80601f016020809104026020016040519081016040528092919081815260200182805461010a90612c95565b80156101575780601f1061012c57610100808354040283529160200191610157565b820191906000526020600020905b81548152906001019060200180831161013a57829003601f168201915b505050505081565b6000806000610177853461281490919063ffffffff16565b905060008873ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b81526004016101b49190612cd6565b602060405180830381865afa1580156101d1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101f59190612d06565b90506000811161023a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161023190612d7f565b60405180910390fd5b60008973ffffffffffffffffffffffffffffffffffffffff1663095ea7b387846040518363ffffffff1660e01b8152600401610277929190612d9f565b6020604051808303816000875af1158015610296573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102ba9190612e00565b9050806102fc576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016102f390612e79565b60405180910390fd5b8573ffffffffffffffffffffffffffffffffffffffff1663f305d719848c8560008030426040518863ffffffff1660e01b815260040161034196959493929190612ede565b60606040518083038185885af115801561035f573d6000803e3d6000fd5b50505050506040513d601f19601f820116820180604052508101906103849190612f3f565b505050606060405160200161039890612fde565b604051602081830303815290604052805190602001208a6040516020016103bf91906128ef565b6040516020818303038152906040528051906020012014156106af5773bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c73ffffffffffffffffffffffffffffffffffffffff168c73ffffffffffffffffffffffffffffffffffffffff161480610468575073bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c73ffffffffffffffffffffffffffffffffffffffff168b73ffffffffffffffffffffffffffffffffffffffff16145b1561055c57600267ffffffffffffffff8111156104885761048761298d565b5b6040519080825280602002602001820160405280156104b65781602001602082028036833780820191505090505b5090508b816000815181106104ce576104cd612ffe565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250508a8160018151811061051d5761051c612ffe565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250506106aa565b600367ffffffffffffffff8111156105775761057661298d565b5b6040519080825280602002602001820160405280156105a55781602001602082028036833780820191505090505b5090508b816000815181106105bd576105bc612ffe565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505073bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c816001815181106106205761061f612ffe565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250508a8160028151811061066f5761066e612ffe565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250505b6109d2565b6040516020016106be90613079565b604051602081830303815290604052805190602001208a6040516020016106e591906128ef565b6040516020818303038152906040528051906020012014156109d15773c02aaa39b223fe8d0a0e5c4f27ead9083c756cc273ffffffffffffffffffffffffffffffffffffffff168c73ffffffffffffffffffffffffffffffffffffffff16148061078e575073c02aaa39b223fe8d0a0e5c4f27ead9083c756cc273ffffffffffffffffffffffffffffffffffffffff168b73ffffffffffffffffffffffffffffffffffffffff16145b1561088257600267ffffffffffffffff8111156107ae576107ad61298d565b5b6040519080825280602002602001820160405280156107dc5781602001602082028036833780820191505090505b5090508b816000815181106107f4576107f3612ffe565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250508a8160018151811061084357610842612ffe565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250506109d0565b600367ffffffffffffffff81111561089d5761089c61298d565b5b6040519080825280602002602001820160405280156108cb5781602001602082028036833780820191505090505b5090508b816000815181106108e3576108e2612ffe565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505073c02aaa39b223fe8d0a0e5c4f27ead9083c756cc28160018151811061094657610945612ffe565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250508a8160028151811061099557610994612ffe565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250505b5b5b8673ffffffffffffffffffffffffffffffffffffffff1663b6f9de95858b843061070842610a0091906130c8565b6040518663ffffffff1660e01b8152600401610a1f94939291906131dc565b6000604051808303818588803b158015610a3857600080fd5b505af1158015610a4c573d6000803e3d6000fd5b505050505060008160018351610a629190613228565b81518110610a7357610a72612ffe565b5b602002602001015173ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401610ab39190612cd6565b602060405180830381865afa158015610ad0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610af49190612d06565b905060008890506060604051602001610b0c90612fde565b604051602081830303815290604052805190602001208d604051602001610b3391906128ef565b604051602081830303815290604052805190602001201415610e235773bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c73ffffffffffffffffffffffffffffffffffffffff168f73ffffffffffffffffffffffffffffffffffffffff161480610bdc575073bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c73ffffffffffffffffffffffffffffffffffffffff168e73ffffffffffffffffffffffffffffffffffffffff16145b15610cd057600267ffffffffffffffff811115610bfc57610bfb61298d565b5b604051908082528060200260200182016040528015610c2a5781602001602082028036833780820191505090505b5090508d81600081518110610c4257610c41612ffe565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250508e81600181518110610c9157610c90612ffe565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff1681525050610e1e565b600367ffffffffffffffff811115610ceb57610cea61298d565b5b604051908082528060200260200182016040528015610d195781602001602082028036833780820191505090505b5090508d81600081518110610d3157610d30612ffe565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505073bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c81600181518110610d9457610d93612ffe565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250508e81600281518110610de357610de2612ffe565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250505b611146565b604051602001610e3290613079565b604051602081830303815290604052805190602001208d604051602001610e5991906128ef565b6040516020818303038152906040528051906020012014156111455773c02aaa39b223fe8d0a0e5c4f27ead9083c756cc273ffffffffffffffffffffffffffffffffffffffff168f73ffffffffffffffffffffffffffffffffffffffff161480610f02575073c02aaa39b223fe8d0a0e5c4f27ead9083c756cc273ffffffffffffffffffffffffffffffffffffffff168e73ffffffffffffffffffffffffffffffffffffffff16145b15610ff657600267ffffffffffffffff811115610f2257610f2161298d565b5b604051908082528060200260200182016040528015610f505781602001602082028036833780820191505090505b5090508d81600081518110610f6857610f67612ffe565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250508e81600181518110610fb757610fb6612ffe565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff1681525050611144565b600367ffffffffffffffff8111156110115761101061298d565b5b60405190808252806020026020018201604052801561103f5781602001602082028036833780820191505090505b5090508d8160008151811061105757611056612ffe565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505073c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2816001815181106110ba576110b9612ffe565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250508e8160028151811061110957611108612ffe565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250505b5b5b60008273ffffffffffffffffffffffffffffffffffffffff1663d06ca61f85846040518363ffffffff1660e01b815260040161118392919061325c565b600060405180830381865afa1580156111a0573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906111c99190613354565b9050600081600183516111dc9190613228565b815181106111ed576111ec612ffe565b5b602002602001015189111561125857611255896112476103e885600187516112159190613228565b8151811061122657611225612ffe565b5b60200260200101518d6112399190613228565b61282a90919063ffffffff16565b61284090919063ffffffff16565b90505b8260008151811061126c5761126b612ffe565b5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1663095ea7b385876040518363ffffffff1660e01b81526004016112ae929190612d9f565b6020604051808303816000875af11580156112cd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112f19190612e00565b5060008511611335576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161132c9061340f565b60405180910390fd5b8373ffffffffffffffffffffffffffffffffffffffff1663791ac9478660008630426040518663ffffffff1660e01b815260040161137795949392919061342f565b600060405180830381600087803b15801561139157600080fd5b505af11580156113a5573d6000803e3d6000fd5b50505050600047905060008573ffffffffffffffffffffffffffffffffffffffff1663d06ca61f838a6040518363ffffffff1660e01b81526004016113eb92919061325c565b600060405180830381865afa158015611408573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906114319190613354565b9050600081600183516114449190613228565b8151811061145557611454612ffe565b5b602002602001015188106114c3576114bc886114ae6103e8856001875161147c9190613228565b8151811061148d5761148c612ffe565b5b60200260200101518c6114a09190613228565b61282a90919063ffffffff16565b61284090919063ffffffff16565b905061158c565b600a8810806114f95750600a82600184516114de9190613228565b815181106114ef576114ee612ffe565b5b6020026020010151105b1561150857610384905061158b565b611588826001845161151a9190613228565b8151811061152b5761152a612ffe565b5b602002602001015161157a6103e88b86600188516115499190613228565b8151811061155a57611559612ffe565b5b602002602001015161156c9190613228565b61282a90919063ffffffff16565b61284090919063ffffffff16565b90505b5b83819d509d50505050505050505050505050965096945050505050565b60008060006115d560646115c760033461282a90919063ffffffff16565b61284090919063ffffffff16565b905060006115ec823461281490919063ffffffff16565b905060606040516020016115ff90612fde565b604051602081830303815290604052805190602001208860405160200161162691906128ef565b6040516020818303038152906040528051906020012014156119165773bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c73ffffffffffffffffffffffffffffffffffffffff168a73ffffffffffffffffffffffffffffffffffffffff1614806116cf575073bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c73ffffffffffffffffffffffffffffffffffffffff168973ffffffffffffffffffffffffffffffffffffffff16145b156117c357600267ffffffffffffffff8111156116ef576116ee61298d565b5b60405190808252806020026020018201604052801561171d5781602001602082028036833780820191505090505b509050898160008151811061173557611734612ffe565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff1681525050888160018151811061178457611783612ffe565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff1681525050611911565b600367ffffffffffffffff8111156117de576117dd61298d565b5b60405190808252806020026020018201604052801561180c5781602001602082028036833780820191505090505b509050898160008151811061182457611823612ffe565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505073bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c8160018151811061188757611886612ffe565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505088816002815181106118d6576118d5612ffe565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250505b611c39565b60405160200161192590613079565b604051602081830303815290604052805190602001208860405160200161194c91906128ef565b604051602081830303815290604052805190602001201415611c385773c02aaa39b223fe8d0a0e5c4f27ead9083c756cc273ffffffffffffffffffffffffffffffffffffffff168a73ffffffffffffffffffffffffffffffffffffffff1614806119f5575073c02aaa39b223fe8d0a0e5c4f27ead9083c756cc273ffffffffffffffffffffffffffffffffffffffff168973ffffffffffffffffffffffffffffffffffffffff16145b15611ae957600267ffffffffffffffff811115611a1557611a1461298d565b5b604051908082528060200260200182016040528015611a435781602001602082028036833780820191505090505b5090508981600081518110611a5b57611a5a612ffe565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250508881600181518110611aaa57611aa9612ffe565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff1681525050611c37565b600367ffffffffffffffff811115611b0457611b0361298d565b5b604051908082528060200260200182016040528015611b325781602001602082028036833780820191505090505b5090508981600081518110611b4a57611b49612ffe565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505073c02aaa39b223fe8d0a0e5c4f27ead9083c756cc281600181518110611bad57611bac612ffe565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250508881600281518110611bfc57611bfb612ffe565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250505b5b5b600061070842611c4991906130c8565b90508673ffffffffffffffffffffffffffffffffffffffff1663b6f9de95848a8530866040518663ffffffff1660e01b8152600401611c8b94939291906131dc565b6000604051808303818588803b158015611ca457600080fd5b505af1158015611cb8573d6000803e3d6000fd5b505050505060008260018451611cce9190613228565b81518110611cdf57611cde612ffe565b5b602002602001015173ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401611d1f9190612cd6565b602060405180830381865afa158015611d3c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d609190612d06565b905060008890506060604051602001611d7890612fde565b604051602081830303815290604052805190602001208c604051602001611d9f91906128ef565b60405160208183030381529060405280519060200120141561208f5773bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c73ffffffffffffffffffffffffffffffffffffffff168e73ffffffffffffffffffffffffffffffffffffffff161480611e48575073bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c73ffffffffffffffffffffffffffffffffffffffff168d73ffffffffffffffffffffffffffffffffffffffff16145b15611f3c57600267ffffffffffffffff811115611e6857611e6761298d565b5b604051908082528060200260200182016040528015611e965781602001602082028036833780820191505090505b5090508c81600081518110611eae57611ead612ffe565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250508d81600181518110611efd57611efc612ffe565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505061208a565b600367ffffffffffffffff811115611f5757611f5661298d565b5b604051908082528060200260200182016040528015611f855781602001602082028036833780820191505090505b5090508c81600081518110611f9d57611f9c612ffe565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505073bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c8160018151811061200057611fff612ffe565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250508d8160028151811061204f5761204e612ffe565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250505b6123b2565b60405160200161209e90613079565b604051602081830303815290604052805190602001208c6040516020016120c591906128ef565b6040516020818303038152906040528051906020012014156123b15773c02aaa39b223fe8d0a0e5c4f27ead9083c756cc273ffffffffffffffffffffffffffffffffffffffff168e73ffffffffffffffffffffffffffffffffffffffff16148061216e575073c02aaa39b223fe8d0a0e5c4f27ead9083c756cc273ffffffffffffffffffffffffffffffffffffffff168d73ffffffffffffffffffffffffffffffffffffffff16145b1561226257600267ffffffffffffffff81111561218e5761218d61298d565b5b6040519080825280602002602001820160405280156121bc5781602001602082028036833780820191505090505b5090508c816000815181106121d4576121d3612ffe565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250508d8160018151811061222357612222612ffe565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250506123b0565b600367ffffffffffffffff81111561227d5761227c61298d565b5b6040519080825280602002602001820160405280156122ab5781602001602082028036833780820191505090505b5090508c816000815181106122c3576122c2612ffe565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff168152505073c02aaa39b223fe8d0a0e5c4f27ead9083c756cc28160018151811061232657612325612ffe565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250508d8160028151811061237557612374612ffe565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250505b5b5b60008273ffffffffffffffffffffffffffffffffffffffff1663d06ca61f85846040518363ffffffff1660e01b81526004016123ef92919061325c565b600060405180830381865afa15801561240c573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906124359190613354565b9050600081600183516124489190613228565b8151811061245957612458612ffe565b5b60200260200101518811156124c4576124c1886124b36103e885600187516124819190613228565b8151811061249257612491612ffe565b5b60200260200101518c6124a59190613228565b61282a90919063ffffffff16565b61284090919063ffffffff16565b90505b826000815181106124d8576124d7612ffe565b5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1663095ea7b385876040518363ffffffff1660e01b815260040161251a929190612d9f565b6020604051808303816000875af1158015612539573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061255d9190612e00565b50600085116125a1576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016125989061340f565b60405180910390fd5b8373ffffffffffffffffffffffffffffffffffffffff1663791ac9478660008630426040518663ffffffff1660e01b81526004016125e395949392919061342f565b600060405180830381600087803b1580156125fd57600080fd5b505af1158015612611573d6000803e3d6000fd5b50505050600047905060008573ffffffffffffffffffffffffffffffffffffffff1663d06ca61f838b6040518363ffffffff1660e01b815260040161265792919061325c565b600060405180830381865afa158015612674573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f8201168201806040525081019061269d9190613354565b9050600081600183516126b09190613228565b815181106126c1576126c0612ffe565b5b6020026020010151881061272f576127288861271a6103e885600187516126e89190613228565b815181106126f9576126f8612ffe565b5b60200260200101518c61270c9190613228565b61282a90919063ffffffff16565b61284090919063ffffffff16565b90506127f8565b600a8810806127655750600a826001845161274a9190613228565b8151811061275b5761275a612ffe565b5b6020026020010151105b156127745761038490506127f7565b6127f482600184516127869190613228565b8151811061279757612796612ffe565b5b60200260200101516127e66103e88b86600188516127b59190613228565b815181106127c6576127c5612ffe565b5b60200260200101516127d89190613228565b61282a90919063ffffffff16565b61284090919063ffffffff16565b90505b5b83819d509d505050505050505050505050509550959350505050565b600081836128229190613228565b905092915050565b600081836128389190613489565b905092915050565b6000818361284e9190613512565b905092915050565b600081519050919050565b600082825260208201905092915050565b60005b83811015612890578082015181840152602081019050612875565b8381111561289f576000848401525b50505050565b6000601f19601f8301169050919050565b60006128c182612856565b6128cb8185612861565b93506128db818560208601612872565b6128e4816128a5565b840191505092915050565b6000602082019050818103600083015261290981846128b6565b905092915050565b6000604051905090565b600080fd5b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600061295082612925565b9050919050565b61296081612945565b811461296b57600080fd5b50565b60008135905061297d81612957565b92915050565b600080fd5b600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6129c5826128a5565b810181811067ffffffffffffffff821117156129e4576129e361298d565b5b80604052505050565b60006129f7612911565b9050612a0382826129bc565b919050565b600067ffffffffffffffff821115612a2357612a2261298d565b5b612a2c826128a5565b9050602081019050919050565b82818337600083830152505050565b6000612a5b612a5684612a08565b6129ed565b905082815260208101848484011115612a7757612a76612988565b5b612a82848285612a39565b509392505050565b600082601f830112612a9f57612a9e612983565b5b8135612aaf848260208601612a48565b91505092915050565b6000819050919050565b612acb81612ab8565b8114612ad657600080fd5b50565b600081359050612ae881612ac2565b92915050565b60008060008060008060c08789031215612b0b57612b0a61291b565b5b6000612b1989828a0161296e565b9650506020612b2a89828a0161296e565b955050604087013567ffffffffffffffff811115612b4b57612b4a612920565b5b612b5789828a01612a8a565b9450506060612b6889828a01612ad9565b9350506080612b7989828a01612ad9565b92505060a0612b8a89828a0161296e565b9150509295509295509295565b612ba081612ab8565b82525050565b6000604082019050612bbb6000830185612b97565b612bc86020830184612b97565b9392505050565b600080600080600060a08688031215612beb57612bea61291b565b5b6000612bf98882890161296e565b9550506020612c0a8882890161296e565b945050604086013567ffffffffffffffff811115612c2b57612c2a612920565b5b612c3788828901612a8a565b9350506060612c4888828901612ad9565b9250506080612c598882890161296e565b9150509295509295909350565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b60006002820490506001821680612cad57607f821691505b60208210811415612cc157612cc0612c66565b5b50919050565b612cd081612945565b82525050565b6000602082019050612ceb6000830184612cc7565b92915050565b600081519050612d0081612ac2565b92915050565b600060208284031215612d1c57612d1b61291b565b5b6000612d2a84828501612cf1565b91505092915050565b7f4e6f20546f6b656e2048656c6400000000000000000000000000000000000000600082015250565b6000612d69600d83612861565b9150612d7482612d33565b602082019050919050565b60006020820190508181036000830152612d9881612d5c565b9050919050565b6000604082019050612db46000830185612cc7565b612dc16020830184612b97565b9392505050565b60008115159050919050565b612ddd81612dc8565b8114612de857600080fd5b50565b600081519050612dfa81612dd4565b92915050565b600060208284031215612e1657612e1561291b565b5b6000612e2484828501612deb565b91505092915050565b7f417070726f76616c206661696c65640000000000000000000000000000000000600082015250565b6000612e63600f83612861565b9150612e6e82612e2d565b602082019050919050565b60006020820190508181036000830152612e9281612e56565b9050919050565b6000819050919050565b6000819050919050565b6000612ec8612ec3612ebe84612e99565b612ea3565b612ab8565b9050919050565b612ed881612ead565b82525050565b600060c082019050612ef36000830189612cc7565b612f006020830188612b97565b612f0d6040830187612ecf565b612f1a6060830186612ecf565b612f276080830185612cc7565b612f3460a0830184612b97565b979650505050505050565b600080600060608486031215612f5857612f5761291b565b5b6000612f6686828701612cf1565b9350506020612f7786828701612cf1565b9250506040612f8886828701612cf1565b9150509250925092565b7f4253430000000000000000000000000000000000000000000000000000000000600082015250565b6000612fc8600383612861565b9150612fd382612f92565b602082019050919050565b60006020820190508181036000830152612ff781612fbb565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f4554480000000000000000000000000000000000000000000000000000000000600082015250565b6000613063600383612861565b915061306e8261302d565b602082019050919050565b6000602082019050818103600083015261309281613056565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60006130d382612ab8565b91506130de83612ab8565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0382111561311357613112613099565b5b828201905092915050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b61315381612945565b82525050565b6000613165838361314a565b60208301905092915050565b6000602082019050919050565b60006131898261311e565b6131938185613129565b935061319e8361313a565b8060005b838110156131cf5781516131b68882613159565b97506131c183613171565b9250506001810190506131a2565b5085935050505092915050565b60006080820190506131f16000830187612b97565b8181036020830152613203818661317e565b90506132126040830185612cc7565b61321f6060830184612b97565b95945050505050565b600061323382612ab8565b915061323e83612ab8565b92508282101561325157613250613099565b5b828203905092915050565b60006040820190506132716000830185612b97565b8181036020830152613283818461317e565b90509392505050565b600067ffffffffffffffff8211156132a7576132a661298d565b5b602082029050602081019050919050565b600080fd5b60006132d06132cb8461328c565b6129ed565b905080838252602082019050602084028301858111156132f3576132f26132b8565b5b835b8181101561331c57806133088882612cf1565b8452602084019350506020810190506132f5565b5050509392505050565b600082601f83011261333b5761333a612983565b5b815161334b8482602086016132bd565b91505092915050565b60006020828403121561336a5761336961291b565b5b600082015167ffffffffffffffff81111561338857613387612920565b5b61339484828501613326565b91505092915050565b7f546f6b656e2042616c616e6365206f662074686973206164647265737320697360008201527f20746f6f206c6f77000000000000000000000000000000000000000000000000602082015250565b60006133f9602883612861565b91506134048261339d565b604082019050919050565b60006020820190508181036000830152613428816133ec565b9050919050565b600060a0820190506134446000830188612b97565b6134516020830187612ecf565b8181036040830152613463818661317e565b90506134726060830185612cc7565b61347f6080830184612b97565b9695505050505050565b600061349482612ab8565b915061349f83612ab8565b9250817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff04831182151516156134d8576134d7613099565b5b828202905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b600061351d82612ab8565b915061352883612ab8565b925082613538576135376134e3565b5b82820490509291505056fea26469706673582212200d6f3dc6f8948a33e76ae40163c3207df4151a580cf3dd0b03379a594ad88bb364736f6c634300080b0033"}

	return e
}
func isContract(address string, client ethclient.Client, ctx context.Context, network string, rpc string, mnemonics string, wgx *sync.WaitGroup, chain chan bool) {
	defer wgx.Done()
	addr := common.HexToAddress(address)
	codeSize, err := client.CodeAt(ctx, addr, nil) //CodeSize(context.Background(), addr)
	if err != nil {
		fmt.Println(err)
	}
	//fmt.Println("Get Chian Assigning RPC")
	chain <- len(codeSize) > 0

}
func (e EthLib) GetChain(address string, ntK chan string, ntkTxt chan string) {
	//fmt.Println("Get Chian Assigning RPC")
	cb, err := ethclient.Dial(e.RPCBSC)
	ce, err := ethclient.Dial(e.RPCETH)
	if err != nil {
		fmt.Println("Error Assigning RPC")
	}
	var dWg sync.WaitGroup
	var isBsc bool
	var isEth bool
	isBsc = false
	isEth = false
	clientBsc = *cb
	clientEth = *ce
	chainBSC := make(chan bool)
	chainEth := make(chan bool)
	dWg.Add(1)
	go isContract(address, clientBsc, e.ctx, "BSC", e.RPCBSC, e.Mnemonic, &dWg, chainBSC)
	dWg.Add(1)
	go isContract(address, clientEth, e.ctx, "ETH", e.RPCETH, e.Mnemonic, &dWg, chainEth)

	isBsc = <-chainBSC
	isEth = <-chainEth
	if isBsc {

		var pairInfo string
		pairInfo = ""
		pInf := make(chan string)

		//go transferToken(address, e.RPCBSC, "BSC", clientBsc)
		dWg.Add(1)
		go whichDEX(address, "BSC", clientBsc, &dWg, pInf)

		pairInfo = <-pInf
		ntK <- pairInfo + " BSC"
		fmt.Println("Per Infor", pairInfo)
		info := strings.Split(pairInfo, " ")

		var taxes []interface{}
		txt := make(chan []interface{})
		lqud, _ := strconv.ParseFloat(info[4], 64)
		mode := ""
		var slttn int = -1
		if lqud > 0 {
			dWg.Add(1)
			go transferTokenDirect(address, info[3], info[7], e.RPCBSC, "BSC", clientBsc, e.ByteCode, &dWg, txt)
		} else {
			mode = "NoLP"
			funcReport := make(chan [][]any)
			dWg.Add(1)
			go getStorageSlot(e.ctx, address, info[3], info[7], e.RPCBSC, "BSC", clientBsc, e.ByteCode, mode, "", -1, &dWg, funcReport)
			sltNum := <-funcReport
			fmt.Println("Slot Number of balance", sltNum[0][0])
			if _, ok := sltNum[0][0].(string); ok {
				slttn = 0
			} else {
				slttn = sltNum[0][0].(int)
			}
			dWg.Add(1)
			go transferTokenDirectNoLP(address, info[3], info[7], e.RPCBSC, "BSC", clientBsc, e.ByteCode, slttn, &dWg, txt)

		}
		taxes = <-txt
		buyTF := taxes[0].(*big.Int)
		buyTFloat := float64(buyTF.Int64()) / 10
		buyTaxes := fmt.Sprintf("%.2f", buyTFloat)

		sellTF := taxes[1].(*big.Int)
		sellTFloat := float64(sellTF.Int64()) / 10
		sellTaxes := fmt.Sprintf("%.2f", sellTFloat)

		fmt.Println("pair Inofr", pairInfo)
		//return pairInfo + " BSC" + " " + buyTaxes + " " + sellTaxes + " " + mode + " " + strconv.Itoa(slttn)
		ntkTxt <- pairInfo + " BSC" + " " + buyTaxes + " " + sellTaxes + " " + mode + " " + strconv.Itoa(slttn)
		close(ntK)
		//close(ntkTxt)
	} else if isEth {

		var pairInfo string
		pairInfo = ""
		pInf := make(chan string)

		//go transferToken(address, e.RPCETH, "ETH", clientEth)
		dWg.Add(1)
		go whichDEX(address, "ETH", clientEth, &dWg, pInf)

		pairInfo = <-pInf
		ntK <- pairInfo + " ETH"
		info := strings.Split(pairInfo, " ")
		fmt.Println("pairInfo", pairInfo)

		//go getStorageSlot(e.ctx, address, info[3], info[7], e.RPCETH, "ETH", clientBsc, e.ByteCode)

		var taxes []interface{}
		txt := make(chan []interface{})
		var slttn int = -1
		mode := ""
		lqud, _ := strconv.ParseFloat(info[4], 64)
		if lqud > 0 {
			dWg.Add(1)
			go transferTokenDirect(address, info[3], info[7], e.RPCETH, "ETH", clientEth, e.ByteCode, &dWg, txt)
		} else {
			mode = "NoLP"
			funcReport := make(chan [][]any)
			dWg.Add(1)
			go getStorageSlot(e.ctx, address, info[3], info[7], e.RPCETH, "ETH", clientEth, e.ByteCode, mode, "", -1, &dWg, funcReport)
			sltNum := <-funcReport
			fmt.Println("Slot Number of balance", sltNum[0][0])
			if _, ok := sltNum[0][0].(string); ok {
				slttn = 0
			} else {
				slttn = sltNum[0][0].(int)
			}
			dWg.Add(1)
			go transferTokenDirectNoLP(address, info[3], info[7], e.RPCETH, "ETH", clientEth, e.ByteCode, slttn, &dWg, txt)

		}

		taxes = <-txt
		buyTF := taxes[0].(*big.Int)
		buyTFloat := float64(buyTF.Int64()) / 10
		buyTaxes := fmt.Sprintf("%.2f", buyTFloat)

		sellTF := taxes[1].(*big.Int)
		sellTFloat := float64(sellTF.Int64()) / 10
		sellTaxes := fmt.Sprintf("%.2f", sellTFloat)

		fmt.Println("pair Inofr", pairInfo)
		//return pairInfo + " ETH" + " " + buyTaxes + " " + sellTaxes + " " + mode + " " + strconv.Itoa(slttn)
		ntkTxt <- pairInfo + " ETH" + " " + buyTaxes + " " + sellTaxes + " " + mode + " " + strconv.Itoa(slttn)
		close(ntK)
		//close(ntkTxt)
	}
	//return "None"
	dWg.Wait()
}

type LockABI struct {
	PinkSale string `xml:"pinksale"`
}
type mainReport struct {
	Token     string
	Owner     string
	MCap      string
	LPRatio   string
	Liquidity string
	LPLocked  string
	Tax       string
	Methods   [][]any
}

func (e EthLib) Simulate(networks string, address string, tokenreport chan string, functionReport chan string, sentimentOrpt chan string) {

	//================ Get Token Info =================
	var dWg sync.WaitGroup
	var client ethclient.Client
	var RPCx string
	var locks []string
	var label []string
	var netLogo string
	var tg string
	network := strings.Split(networks, " ")[8]
	//var rpc string
	//rpc = ""
	var scann string
	fmt.Println("Trade Sumeerry", network)
	switch network {
	case "BSC":
		client = clientBsc
		locks = []string{"0x407993575c91ce7643a4d4ccacc9a98c36ee1bbe", "0xae7e6cabad8d80f0b4e1c4dde2a5db7201ef1252", "0xC765bddB93b0D1c1A88282BA0fa6B2d00E3e0c83", address, "0x4C733359a195dd2e55170048986B7787B3B61576", "0xe0c3ab2c69d8b43d8B0D922aFa224A0AB6780dE1", "0x3f4D6bf08CB7A003488Ef082102C2e6418a4551e", "0x0C89C0407775dd89b12918B9c0aa42Bf96518820", "0xa36037dC26C5C02e864eBA969A312320E6487269", "0xd2D33161dC72Dd1254c74c44d809F8273304CF8C", "0xfdf0dDCec77da7Eb8Fa5c443bDEC1820eE38cCc3"}
		label = []string{"PinkSale", "Mudra", "UniCrypt", "Contract", "TokenTool", "Cryptex", "Deeplocker", "TrustSwap", "Bscrypt", "UniLocker", "CookieSale"}
		RPCx = e.RPCBSC
		netLogo = "🔸"
		tg = getTelegram(address, "BSC")
		scann = "https://bscscan.com//address/"
	case "ETH":
		client = clientEth
		locks = []string{"0x663A5C229c09b049E36dCc11a9B0d4a8Eb9db214", "0xE2fE530C047f2d85298b07D9333C05737f1435fB", address, "0x71B5759d73262FBb223956913ecF4ecC51057641", "0xdF77a4d44D5fB29BC906e645168fD7c224E1B55D"}
		label = []string{"UniCrypt", "TrustSwap", "Contract", "PinkSale", "UniLocker"}
		RPCx = e.RPCETH
		netLogo = "🔹"
		tg = getTelegram(address, "ETH")
		scann = "https://etherscan.io/address/"
	}
	// Get Owner
	var theowner string
	theowner = getDeployedOwner(address, network)

	var pairInfo string
	pairInfo = networks

	//================ Get the abi =================
	var parsAbi abi.ABI

	abiP := make(chan abi.ABI)
	dWg.Add(1)
	fmt.Println("========Number of go rountin3 Inside 1", runtime.NumGoroutine())
	go func(abiP chan abi.ABI, wg *sync.WaitGroup) {
		defer wg.Done()
		tokenAbi := getAbi(address, network)
		parsedAbi, err := abi.JSON(strings.NewReader(tokenAbi))
		if err != nil {
			fmt.Println("Abi Parse", err)
		}
		abiP <- parsedAbi

	}(abiP, &dWg)
	var lpMode string = ""
	//============ Based ============
	if pairInfo != "Empty" {
		info := strings.Split(pairInfo, " ")
		blSlt, _ := strconv.Atoi(info[12])
		funcReport := make(chan [][]any)
		fmt.Println("========Number of go rountin3 Inside 2", runtime.NumGoroutine())
		dWg.Add(1)
		go getStorageSlot(e.ctx, address, info[3], info[7], RPCx, network, client, e.ByteCode, "", info[11], blSlt, &dWg, funcReport)
		var theReport [][]any

		//theReport := <-funcReport
		fmt.Println("Prev Owner 1")
		var LPLockedInfo string
		lppp := make(chan string)
		if info[11] == "NoLP" {
			lpMode = " | <b>SIMULATED</b>"
		}
		// ====== Get Lock Information =====

		lockInnff := func(lppp chan string, wgx *sync.WaitGroup) {
			defer wgx.Done()
			fmt.Println("Statr Lock")
			var wg sync.WaitGroup
			var foundLP bool = false
			ctx, cancel := context.WithCancel(context.Background())
			defer cancel()
			for i, lckFct := range locks {
				lpInf := make(chan string)
				donx := make(chan bool)
				wg.Add(1)
				go func(lpInf chan string, donex chan bool, ix int, lckFct string, label string) {

					defer wg.Done()
					lpLocked := make(chan string)
					var lpLockInfo string
					lpLockInfo = "Empty"
					pncSupl, _ := strconv.ParseFloat(info[6], 64)
					if pncSupl > 0 {
						wg.Add(1)

						go getLocked(info[0], lckFct, label, e.ctx, client, &wg, lpLocked)

						//lpLockInfo = <-lpLocked
						//fmt.Println("========Number of go rountin3 Inside 4", runtime.NumGoroutine())
						select {
						case lpLockInfo = <-lpLocked:
							fmt.Println("========Number of goroutines Inside 4", runtime.NumGoroutine())
						case <-ctx.Done():
							return
						}
					}
					if lpLockInfo != "Empty" {
						lpDetails := strings.Split(lpLockInfo, " ")
						fmt.Println("Locked", lpDetails[0]+"% Liquidity in "+lpDetails[1])

						lpInf <- "<b>" + lpDetails[0] + "%</b> Liquidity in <b>" + lpDetails[1] + "</b>"

						donex <- true
						cancel()
					} else {

						lpInf <- "Unknown Lock"
						donex <- true
						cancel()
					}

					fmt.Println("GoRoutine", ix, lckFct, label, len(locks)-1)

				}(lpInf, donx, i, lckFct, label[i])
				select {
				case x := <-lpInf:

					if x != "Unknown Lock" {

						fmt.Println("GoRoutine::-", x)
						lppp <- x
						//close(lpInf)
						foundLP = true
						break
					}
					close(lpInf)
					fmt.Println("========Number of goroutines Inside 3", runtime.NumGoroutine(), x)
				case <-ctx.Done():
					return
				}
				//fmt.Println("========Number of go rountin3 Inside 3", runtime.NumGoroutine())
				//wg.Add(1)
				/*go func(ctx context.Context) {

					defer wg.Done()
					//var LPSINF []string
					var recieved bool = false
					for {
						select {
						case x := <-lpInf:
							//LPLockedInfo = x

							if x != "Unknown Lock" {

								fmt.Println("GoRoutine::-", x)
								lppp <- x
								//close(lppp)
								foundLP = true
								recieved = true

								break
							}

						default:
							//"return"
						}
						if recieved {
							cancel()
							break
						}

					}
				}(ctx)*/

				fmt.Println("========Number of go rountin3 Inside 7", runtime.NumGoroutine())
			}

			wg.Wait()
			fmt.Println("========Number of go rountin3 Inside 8", runtime.NumGoroutine())
			//xx := <-lppp

			if foundLP == false {
				fmt.Println("LP Info:- Unknown")
				lppp <- "Unknown Lock"
			}
			//close(lppp)
		}
		dWg.Add(1)
		fmt.Println("========Number of go rountin3 Inside 6", runtime.NumGoroutine())
		go lockInnff(lppp, &dWg)

		dWg.Add(1)
		lpLK := make(chan string)
		go func(lpLK chan string) {
			defer dWg.Done()
			var LPSINF []string
			//outerLoop:
			var end bool = false
			var LPLockedInfox string
			for {
				select {
				case x := <-lppp:

					LPSINF = append(LPSINF, x)
					fmt.Println("Locked:----", x)
					time.Sleep(1 * time.Second)
					break
				default:
					//{pass}
				}
				if len(LPSINF) > 0 {
					for i, x := range LPSINF {
						if strings.Contains(x, "Unknown Lock") == false {
							LPLockedInfox = x

							lpLK <- LPLockedInfox
							end = true
							break
						}
						if i == len(LPSINF)-1 {
							LPLockedInfox = "Unknown Lock"
							lpLK <- LPLockedInfox
							end = true
						}
					}
				}
				if end {
					break
				}

			}

		}(lpLK)

		dWg.Add(1)
		go func() {
			defer dWg.Done()
			// ==== Load ABI Func ====== and get owner

			parsAbi = <-abiP
			//parsAbi.

			var contNma string = getTokenName(e.ctx, address, client)

			var maxST *big.Int = big.NewInt(0)
			var allMax []*big.Int
			var allMaxName []string
			wnn := make(chan string)
			//contractName := make(chan string)
			maxsell := make(chan *big.Int)

			i := 0
			fmt.Println("Prev Owner", theowner)

			for _, method := range parsAbi.Methods {
				if method.Constant {
					continue
				}
				//fmt.Println(method.)
				if (strings.ToLower(method.Name)) == "owner" { // Get Owner check
					dWg.Add(1)
					go func(method string, wnn chan string) {
						defer dWg.Done()
						fmt.Println(strings.ToLower(method), "=owner")

						contAdde := common.HexToAddress(address)
						wn, err := parsAbi.Pack(method)
						if err != nil {
							fmt.Println("GettingOwner Error:-", err)
						}
						result, err := client.CallContract(e.ctx, ethereum.CallMsg{To: &contAdde, Data: wn}, nil)
						if err != nil {
							fmt.Println("GettingOwnerResult Error:-", err)
						}

						var output common.Address
						err = parsAbi.UnpackIntoInterface(&output, method, result)
						if err != nil {
							panic(err)
						}
						dead := common.HexToAddress("0x000000000000000000000000000000000000dEaD")
						ded := common.HexToAddress("0x0000000000000000000000000000000000000000")

						if (output == dead) || (output == ded) {

							wnn <- "****Renounced****"

						} else {

							wnn <- string(output.Hex())
						}

					}(method.Name, wnn)
					theowner = <-wnn
				}
				if strings.Contains(strings.ToLower(method.Name), "max") { // Get Owner check
					_, err := parsAbi.Pack(method.Name)
					if err == nil {
						dWg.Add(1)
						go func(method string, wnn chan *big.Int) {
							defer dWg.Done()
							fmt.Println(strings.ToLower(method), "=owner")

							contAdde := common.HexToAddress(address)
							wn, err := parsAbi.Pack(method)
							if err != nil {
								fmt.Println("GettingOwner Error:-", err)
							}
							result, err := client.CallContract(e.ctx, ethereum.CallMsg{To: &contAdde, Data: wn}, nil)
							if err != nil {
								fmt.Println("GettingOwnerResult Error:-", err)
								wnn <- big.NewInt(0)
							} else {

								var output interface{}
								err = parsAbi.UnpackIntoInterface(&output, method, result)
								if err != nil {
									panic(err)
								}
								fmt.Println("MaxSellout", output)
								maxTrx := output.(*big.Int)
								fmt.Println("MaxSellout2", maxTrx.Int64())
								wnn <- maxTrx //.Int64()
								allMaxName = append(allMaxName, method)
							}
						}(method.Name, maxsell)
						maxST = <-maxsell
						allMax = append(allMax, maxST)
					}
				}
				i += 1
			}

			// ====== Report ========
			var safetyMeter string
			var overallSafety string
			var methodSafety int = 0
			var reportsFunc []interface{}
			functionRPT := func() {
				rtptt := make(chan []interface{})
				dWg.Add(1)
				go func(rpt chan []interface{}) {
					defer dWg.Done()
					flatArray := make([]interface{}, 0)
					flattenNestedArrays(theReport, &flatArray)
					rpt <- flatArray
				}(rtptt)
				reportsFunc = <-rtptt
				var functReportStr string = ""
				var malFunc int = 0
				fmt.Println("FLated Array", reportsFunc)
				for ix, functions := range reportsFunc {

					if v, ok := functions.(string); ok {
						if v == "Empty" {
							if strv, ok := reportsFunc[ix-1].(string); ok {
								if strv == "GOOD" {
									functReportStr = functReportStr + ", 🔘" + "<b>" + reportsFunc[ix-2].(string) + "</b> ❗️"
								} else if strv == "Empty" {
									functReportStr = functReportStr + "❗️"
								} else {
									functReportStr = functReportStr + ", 🔘" + "<b>" + strv + "</b> ❗️"
								}

							}
							//functReportStr = functReportStr + "X"
							malFunc += 1

						}
						if v == "Not Verified" {
							//if strv, ok := reportsFunc[ix].(string); ok {
							functReportStr = " ❗️Contract " + v
							malFunc += 100
							//}

						}
					}
				}

				fmt.Println("Flaten Arrya", functReportStr)
				if functReportStr != "" {
					functReportStr = functReportStr[1:]
				} else {
					functReportStr = "✅"
				}
				// ======== Calculate Saftey ========
				safety := (float64(malFunc) / float64(len(reportsFunc))) * 100
				fmt.Println("MalFunctions", malFunc, safety)

				switch {

				case safety < 10:
					safetyMeter = "🟢🟢🟢🟢"
					methodSafety = 100
				case safety < 20:
					safetyMeter = "🟢🟡"
					//overallSafety = "🟡"
					methodSafety = 80
				case safety < 30:
					safetyMeter = "🟡"
					//overallSafety = "🟡"
					methodSafety = 70
				case safety < 40:
					safetyMeter = "🟡🟡"
					//overallSafety = "🟠"
					methodSafety = 60
				case safety < 50:
					safetyMeter = "🟡🟡🟠"
					//overallSafety = "🟠"
					methodSafety = 50
				case safety < 60:
					safetyMeter = "🟡🟠🟠"
					//overallSafety = "🟠"
					methodSafety = 40
				case safety < 70:
					safetyMeter = "🟠🟠🔴"
					//overallSafety = "🔴"
					methodSafety = 30
				case safety < 80:
					safetyMeter = "🔴"
					//overallSafety = "🔴"
					methodSafety = 20
				case safety < 90:
					safetyMeter = "🔴🔴🔴"
					//overallSafety = "🔴"
					methodSafety = 10
				case safety < 101:
					safetyMeter = "🔴🔴🔴🔴"
					//overallSafety = "🔴"
					methodSafety = 0
				case safety > 101:
					safetyMeter = "🔴🔴🔴🔴"
					//overallSafety = "🔴"
					methodSafety = 0
				}
				if strings.Contains(strings.ToLower(functReportStr), "implementation") {
					functReportStr = functReportStr + " (Proxy Contract ❗️)"
					overallSafety = "🔴"
				}
				reptFunc := `
<code>_______________________________</code>
<code><b>Contract Functions Analysis</b></code>
<code>_______________________________</code>
⚠️ <b>?Mali-Func:</b>    %s
⁉️ <b>Report:</b>    %s
<code>_______________________________</code>
<code><b>Always DYOR. Auto rugcheckers cannot detect all scams.</b></code>

<code><b>⏱ Performing Sentiment Analysis. Please Wait...(2 mins)</b></code>
`
				fmt.Println("Function Report:-", fmt.Sprintf(reptFunc, functReportStr, safetyMeter))
				functionReport <- fmt.Sprintf(reptFunc, functReportStr, safetyMeter)
			}
			dWg.Add(1)
			go func() {
				defer dWg.Done()
				for {
					select {
					case x := <-funcReport:
						theReport = x
						functionRPT()
						time.Sleep(1 * time.Second)
						break
					default:
						//{pass}
					}
				}
			}()
			token_decimal := getTokenDecima(common.HexToAddress(address), client)
			var mxBuy float64 = 0
			var mxSell float64 = 0
			var mxWallet float64 = 0
			var mxTx float64 = 0
			dones := make(chan bool)
			dWg.Add(1)
			go func(dones chan bool) {
				defer dWg.Done()
				if len(allMax) > 0 {
					for x, Tx := range allMax {
						maxSellPx := new(big.Float).Quo(big.NewFloat(0).SetInt(Tx), big.NewFloat(0).SetInt(big.NewInt(int64(math.Pow(10, float64(token_decimal)))))) ///float64(Tx) / float64(math.Pow(10, float64(token_decimal)))
						maxSellPrx, _ := maxSellPx.Float64()
						switch {
						case strings.Contains(strings.ToLower(allMaxName[x]), "buy"):
							mxBuy = maxSellPrx
						case strings.Contains(strings.ToLower(allMaxName[x]), "sell"):
							mxSell = maxSellPrx
						case strings.Contains(strings.ToLower(allMaxName[x]), "wallet"):
							mxWallet = maxSellPrx
						case strings.Contains(strings.ToLower(allMaxName[x]), "tx"):
							mxTx = maxSellPrx
						}
					}
				}
				dones <- true
			}(dones)
			<-dones
			//go func() {
			toUSD, decimal, _ := convertToUsdt(info[3], info[7], network, &client)
			Equv := big.NewInt(0).Div(toUSD[1], big.NewInt(int64(math.Pow(10, float64(decimal)))))
			fmt.Println("Information", info, Equv)
			ttsly, _ := strconv.ParseFloat(info[5], 64)

			pncSupl, _ := strconv.ParseFloat(info[6], 64)

			lpratio := (pncSupl / ttsly) * 100

			lqud, _ := strconv.ParseFloat(info[4], 64)
			EquvUSd := float64(Equv.Int64()) * lqud
			mcap := 0.00
			if pncSupl > 0 {
				mcap = (lqud / pncSupl) * float64(Equv.Int64()) * ttsly
			}
			LPLockedInfo = <-lpLK
			mmmm := mainReport{
				Token:     "Token:- " + network + ":" + address,
				Owner:     "Owner:- " + theowner,
				MCap:      "MCap:- " + fmt.Sprintf("$ %f in USD(%d)", mcap, Equv.Int64()),
				LPRatio:   "LPRatio:- " + fmt.Sprintf("%.2f", lpratio) + "% in " + info[1],
				Liquidity: "Liquidity:- " + info[4] + " " + info[2] + fmt.Sprintf("($%f)", EquvUSd),
				LPLocked:  "Locked:- " + LPLockedInfo,
				Tax:       "Tax:- " + fmt.Sprintf("Buy Tax: %s | Sell Tax: %s", info[9], info[10]),
				Methods:   theReport,
			}

			var ownerPower int = 0
			if theowner == "****Renounced****" {
				ownerPower = 100
			} else {
				ownerPower = 0
			}
			var taxSafety int = 0
			buyTx, _ := strconv.ParseFloat(info[9], 64)
			sellTx, _ := strconv.ParseFloat(info[9], 64)

			switch {
			case buyTx < 20 || sellTx < 20:
				taxSafety = 100
			case buyTx < 50 || sellTx < 50:
				taxSafety = 50
			case buyTx > 50 || sellTx > 50:
				taxSafety = 0
			}
			var lpSafety int = 0
			switch {
			case lpratio < 10:
				lpSafety = 0
				safetyMeter = safetyMeter + "🍯 <b>Honey Pot:   LOW LIQUIDITY</b> "
			case lpratio < 20:
				lpSafety = 10
			case lpratio < 50:
				lpSafety = 50
			case lpratio < 101:
				lpSafety = 100
			case lpratio > 101:
				lpSafety = 0
				safetyMeter = safetyMeter + "🍯 <b>Honey Pot:   LOW LIQUIDITY</b> "
			case lpMode == " | <b>SIMULATED</b>":
				lpSafety = 100
			}
			var lockSafety int = 0
			if LPLockedInfo != "Unknown Lock" {
				lockSafety = 100
			} else if lpMode == " | <b>SIMULATED</b>" {
				lockSafety = 100
			}
			//Total Safety Calculation
			totalSafetyAvg := (methodSafety + ownerPower + taxSafety + lpSafety + lockSafety) / 5
			fmt.Println("Total Safety", totalSafetyAvg, methodSafety, ownerPower, taxSafety, lpSafety, lockSafety, "Isit ProxyAddress:-", isEVMProxyContract(address, client))

			switch {
			case totalSafetyAvg < 20:
				overallSafety = "🚫"
			case totalSafetyAvg < 40:
				overallSafety = "🔴"
			case totalSafetyAvg < 60:
				overallSafety = "🟠"
			case totalSafetyAvg < 80:
				overallSafety = "🟡"
			case totalSafetyAvg < 101:
				overallSafety = "🟢"
			}

			if buyTx > 50 || sellTx > 50 {
				overallSafety = "🔴"
				safetyMeter = safetyMeter + "🍯 <b>Honey Pot:   High Tax</b> "
			}
			message := `
@SafreeAnalyzerbot  |  <b>%s</b>  |  %s
%s <b>%s:</b>        <code> %s</code>
👨‍💻 <b>Owner:</b>     <b> %s</b>
💧 <b>LP Ratio:</b>   <code>%s</code> in <a href="%s">%s</a>
💲 <b>MCap:</b>      %s
💰 <b>Liquidity:</b> <b>%s</b> %s
🔒 <b>LP Lock:</b>   %s
🔖 <b>Tax:</b>          %s
🎯 <b>MaxTrnx1:</b>  Sell: <code>%s</code> | Buy:<code> %s </code>
🎯 <b>MaxTrnx2:</b>  Tx: <code>%s</code> | Wallet <code>%s</code>
🥏 <b>Telegram:</b>  %s
%s
`

			fmt.Println("Report:-", fmt.Sprintf(message, network, address, theowner, fmt.Sprintf("%.2f", lpratio), info[1], fmt.Sprintf("$ <b>%f</b> in USD($%d)", mcap, Equv.Int64()), info[4], info[2]+fmt.Sprintf("($%f)", EquvUSd), LPLockedInfo, fmt.Sprintf("Buy Tax: %s | Sell Tax: %s", info[9], info[10]), theReport), mmmm)

			tokenreport <- fmt.Sprintf(message, contNma, overallSafety+lpMode, netLogo, network, address, theowner, fmt.Sprintf("%.2f", lpratio), scann+info[0], info[1], fmt.Sprintf("$ <b>%f</b> in USD(%d)", mcap, Equv.Int64()), info[4], info[2]+fmt.Sprintf("($%f)", EquvUSd), LPLockedInfo, fmt.Sprintf("Buy Tax: <code>%s</code> | Sell Tax: <code>%s</code>", info[9], info[10]), fmt.Sprintf("%.2f", mxSell), fmt.Sprintf("%.2f", mxBuy), fmt.Sprintf("%.2f", mxTx), fmt.Sprintf("%.2f", mxWallet), tg, safetyMeter)

			//=======Sentiments=======
			sentOrpt := make(chan string)
			if lpMode != " | <b>SIMULATED</b>" {
				dWg.Add(1)
				go func(client ethclient.Client, network string, address string, sentOrpt chan string, contNma string) {
					defer dWg.Done()
					intervals := []time.Duration{30 * time.Second, 30 * time.Second, 30 * time.Second, 30 * time.Second}
					msgg := `
<code>_______________________________</code>
<code><b>Trade Sentiment of %s</b></code>
<code>_______________________________</code>
%s	

📈 Report: %s
<code>_______________________________</code>
<code><b>Always DYOR. Auto rugcheckers cannot detect all scams.</b></code>			
				`
					var fullRPT string = ""
					var currTime time.Duration
					var prxChng []float64
					var bullRPT int = 0
					for i, interval := range intervals {
						time.Sleep(interval)
						pInf := make(chan string)
						lppLc := make(chan string)
						dWg.Add(1)
						go whichDEX(address, network, client, &dWg, pInf)
						dWg.Add(1)
						go lockInnff(lppLc, &dWg)
						lockInfo := <-lppLc
						pairInfo := <-pInf
						info := strings.Split(pairInfo, " ")

						toUSD, decimal, _ := convertToUsdt(info[3], info[7], network, &client)
						Equv := big.NewInt(0).Div(toUSD[1], big.NewInt(int64(math.Pow(10, float64(decimal)))))

						ttsly, _ := strconv.ParseFloat(info[5], 64)

						pncSupl, _ := strconv.ParseFloat(info[6], 64)

						lpratio := (pncSupl / ttsly) * 100

						lqud, _ := strconv.ParseFloat(info[4], 64)
						EquvUSd := float64(Equv.Int64()) * lqud
						mcap := 0.00
						currentPrx := 0.00
						if pncSupl > 0 {
							mcap = (lqud / pncSupl) * float64(Equv.Int64()) * ttsly
							currentPrx = (lqud / pncSupl) * float64(Equv.Int64())
						}

						currTime = currTime + interval

						chng := 0.0
						if len(prxChng) > 0 {
							chng = ((currentPrx - prxChng[i-1]) / currentPrx) * 100
						}
						//var bullishRPT = ""
						switch {
						case chng < 10:
							if lockInfo != "Unknown Lock" {
								bullRPT += 10
							} else {
								bullRPT += 0
							}

						case chng < 20:
							if lockInfo != "Unknown Lock" {
								bullRPT += 20
							} else {
								bullRPT += 5
							}

						case chng < 40:
							if lockInfo != "Unknown Lock" {
								bullRPT += 40
							} else {
								bullRPT += 10
							}
						case chng < 60:
							if lockInfo != "Unknown Lock" {
								bullRPT += 60
							} else {
								bullRPT += 15
							}

						case chng < 80:
							if lockInfo != "Unknown Lock" {
								bullRPT += 80
							} else {
								bullRPT += 20
							}
						case chng <= 100:
							if lockInfo != "Unknown Lock" {
								bullRPT += 100
							} else {
								bullRPT += 25
							}

						}
						prxChng = append(prxChng, currentPrx)
						fmt.Println("Report after ", interval, lpratio, EquvUSd, mcap, "Lock Info", lockInfo, "Price", fmt.Sprintf("%.8f", currentPrx))

						rpt := "<b><u>⏱ After " + currTime.String() + "</u></b>\n<b>💲Price:-  " + fmt.Sprintf("<code>$ %.15f  (%.2f", currentPrx, chng) + "%)</code></b> \n<b>💲 MCap:-  " + fmt.Sprintf("<code>$ %.3f</code>", mcap) + "</b>  |  <b> LP-Ratio:-  " + fmt.Sprintf("<code>%.2f", lpratio) + "%</code></b>\n🔒 <b>LP Lock:-  </b>" + lockInfo
						fullRPT = fullRPT + "\n\n\n" + rpt

					}
					chng := bullRPT / len(intervals)
					var bullishRPT = ""
					switch {
					case chng < 10:

						bullishRPT = "🔴"

					case chng < 20:

						bullishRPT = "🟠🟠🟠"

					case chng < 40:

						bullishRPT = "🟡🟡🟡"

					case chng < 60:

						bullishRPT = "🟢🟢🟢"

					case chng < 80:

						bullishRPT = "🔵🔵🔵"

					case chng <= 100:

						bullishRPT = "🟣🟣🟣"

					}
					sentOrpt <- fmt.Sprintf(msgg, contNma, "<b>"+fullRPT[6:], bullishRPT)
				}(client, network, address, sentOrpt, contNma)
				sentOxxrpt := <-sentOrpt
				fmt.Println(sentOxxrpt)
				sentimentOrpt <- sentOxxrpt
			} else {
				msgg := `
<code>_______________________________</code>
<code><b>Trade Sentiment of %s</b></code>
<code>_______________________________</code>
❗️ <b>Simulation Mode NO LP Added Yet</b>
<code>_______________________________</code>
<code><b>Always DYOR. Auto rugcheckers cannot detect all scams.</b></code>			
				`
				sentimentOrpt <- fmt.Sprintf(msgg, contNma)
				close(sentimentOrpt)
				close(functionReport)
				close(tokenreport)
			}
		}()

	}
	dWg.Wait()
	//return "None"
}
func isEVMProxyContract(contractAddress string, client ethclient.Client) bool {
	address := common.HexToAddress(contractAddress)

	// Fetch the bytecode of the contract
	bytecode, err := client.CodeAt(context.Background(), address, nil)
	if err != nil {
		// Handle error
		return false
	}

	// Calculate the EIP-1167 minimal proxy bytecode
	proxyBytecode := crypto.Keccak256Hash([]byte("eip1967.proxy.implementation")).Bytes()
	fmt.Println("ProxyBytecode", hexutil.Encode(proxyBytecode))
	// Compare the contract bytecode with the proxy bytecode
	return bytes.HasPrefix(bytecode, proxyBytecode)
}

func getTokenName(ctx context.Context, address string, client ethclient.Client) string {
	const contractABI = `[{"constant":true,"inputs":[],"name":"name","outputs":[{"name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"}]`

	parsAbi, err := abi.JSON(strings.NewReader(contractABI))
	if err != nil {
		fmt.Println("Abi Parse", err)
	}
	contAdde := common.HexToAddress(address)
	wn, err := parsAbi.Pack("name")
	if err != nil {
		fmt.Println("GettingOwner Error:-", err)
	}
	result, err := client.CallContract(ctx, ethereum.CallMsg{To: &contAdde, Data: wn}, nil)
	if err != nil {
		fmt.Println("GettingOwnerResult Error:-", err)
	}

	var output interface{}
	err = parsAbi.UnpackIntoInterface(&output, "name", result)
	if err != nil {
		panic(err)
	}
	return output.(string)
}
func flattenNestedArrays(arrays [][]interface{}, flatArray *[]interface{}) {
	for _, item := range arrays {
		for _, element := range item {
			switch reflect.TypeOf(element).Kind() {
			case reflect.Slice:
				if reflect.TypeOf(element).Elem().Kind() == reflect.Int {
					*flatArray = append(*flatArray, "Success")
				} else {
					flattenNestedArrays(element.([][]interface{}), flatArray)
				}
			default:
				*flatArray = append(*flatArray, element)
			}
		}
	}
}
func joinInterfaceSlice(slice []interface{}, sep string) interface{} {
	strSlice := make([]string, len(slice))
	for i, v := range slice {
		strSlice[i] = fmt.Sprintf("%v", v)
	}
	joined := strings.Join(strSlice, sep)
	return interface{}(joined)
}

type SolidityTreeListener struct {
	*solidityparser.BaseSolidityListener
	Address           string
	Fiat              string
	Dex               string
	RPCX              string
	Network           string
	Client            ethclient.Client
	result            [][]int
	currentSlot       []int
	currentBytes      int
	slotarray         []int
	StructStorage     string
	StructLen         int
	TypeNameOfVar     string
	OwnersAddress     string
	StateVariables    [][]interface{}
	ByteCodes         string
	CalledStateV      []string
	Report            [][]interface{}
	ChannelReport     func([][]any)
	WaitGroup         sync.WaitGroup
	Mode              string
	TradeMode         string
	BalaNXSlot        int
	BalanceSlotNumber func(int)
	ContractType      string
}

func (l *SolidityTreeListener) EnterEveryRule(ctx antlr.ParserRuleContext) {
	//go func() {
	if structVarCtx, ok := ctx.(*solidityparser.StructDefinitionContext); ok {
		l.EnterStructDefinition(*structVarCtx)

	}
	if contract, ok := ctx.(*solidityparser.ContractDefinitionContext); ok {
		//fmt.Println("isAbstract", strings.Split(contract.GetText(), "{")[0])
		l.ContractType = strings.Split(contract.GetText(), "{")[0]
	}
	if stateVarCtx, ok := ctx.(*solidityparser.StateVariableDeclarationContext); ok {
		//fmt.Println("isAbstract", l.ContractType)
		rcc := regexp.MustCompile(`^abstractcontract\w+is\w+`)
		if strings.Contains(l.ContractType, "abstractcontract") {
			if rcc.MatchString(l.ContractType) {
				//if strings.Contains(strings.ToLower(l.ContractType), "ownable") == false {
				l.EnterStateVariableDeclaration(*stateVarCtx)
				//}
			}
			//pass
		} else {
			l.EnterStateVariableDeclaration(*stateVarCtx)
		}

	}
	if funDiscr, ok := ctx.(*solidityparser.FunctionDefinitionContext); ok {

		l.EnterFunctionDefinition(*funDiscr)
	}

	//}()
}
func (l *SolidityTreeListener) ExitEveryRule(ctx antlr.ParserRuleContext) {
	//fmt.Println("End of Tree", ctx.GetRuleContext().GetRuleIndex())
	if ctx.GetRuleContext().GetRuleIndex() == 0 {
		// Rule index 0 represents the top-level rule in your grammar
		fmt.Println("End of tree reached")

	}

}
func (s *SolidityTreeListener) EnterStructDefinition(ctx solidityparser.StructDefinitionContext) {
	allV := ctx.AllVariableDeclaration()
	fmt.Println("Strutct", ctx.GetText())
	s.StructLen = len(allV)
	s.StructStorage = ctx.GetText()

}

var sss int = 0

func (s *SolidityTreeListener) EnterFunctionDefinition(ctx solidityparser.FunctionDefinitionContext) {

	allV := ctx.Block()
	if allV != nil {
		sss += 1
		varCntx := ctx.Block().AllStatement()
		s.WaitGroup.Add(1)
		go func(wg *sync.WaitGroup) {
			defer wg.Done()
			end := len(varCntx)
			for ixx, stmt := range varCntx {
				if stmt.(*solidityparser.StatementContext).SimpleStatement() != nil {
					//if stmt.(*solidityparser.StatementContext).SimpleStatement().(*solidityparser.SimpleStatementContext).VariableDeclarationStatement() != nil {
					varbl := stmt.(*solidityparser.StatementContext).SimpleStatement().(*solidityparser.SimpleStatementContext) //.VariableDeclarationStatement().(*solidityparser.VariableDeclarationStatementContext)
					r := regexp.MustCompile(`\w+\[(\w+)\]\s*([-+])=`)                                                           //(`\w+\[(\w+)\]\s*=`)
					for _, stVr := range s.StateVariables {
						var IsNewVariable bool = true
						for _, free := range s.CalledStateV {
							if free == stVr[0].(string) {
								IsNewVariable = false
								break
							}
						}
						//fmt.Println("USed Variable", s.CalledStateV)
						if (strings.Contains(varbl.GetText(), stVr[0].(string)+"=") || strings.Contains(varbl.GetText(), stVr[0].(string)+".push(") || strings.Contains(r.FindString(varbl.GetText()), stVr[0].(string))) && ctx.FunctionDescriptor().Identifier() != nil && IsNewVariable && s.Mode == "" {
							var FunName []any
							if strings.Contains(r.FindString(varbl.GetText()), stVr[0].(string)) {
								fmt.Println("MMMM,", r.FindString(varbl.GetText()), "StateVart", stVr[0].(string))
							}
							if strings.Contains(varbl.GetText(), stVr[0].(string)+".push(") {
								fmt.Println("Ayyyy,", "StateVart", stVr[0].(string))
							}
							fmt.Println("====>Function", varbl.GetText(), "=====> NAme", ctx.FunctionDescriptor().Identifier().GetText(), "====>Discript", stVr[4], "Slot:-", stVr[2].(int), "Package Update", s.Report)
							FunName = append(FunName, ctx.FunctionDescriptor().Identifier().GetText())
							isTrade := make(chan [][]any)
							s.WaitGroup.Add(1)
							go theSlotData(context.Background(), s.Address, stVr[2].(int), s.Network, s.Client, stVr[1].(string), stVr[3].(string), s.OwnersAddress, s.Fiat, s.Dex, s.RPCX, ctx.FunctionDescriptor().Identifier().GetText(), stVr[0].(string), s.ByteCodes, s.TradeMode, s.BalaNXSlot, &s.WaitGroup, isTrade)

							xxx := <-isTrade
							FunName = append(FunName, xxx)
							s.Report = append(s.Report, FunName)
							fmt.Println("Function Name Report", s.Report, "I report", ixx, "End Game", end)
							//if ixx == end-1 {
							s.ChannelReport(s.Report)
							fmt.Println("Reached end of range")
							//}
							fmt.Println("End of Tree", "Test", sss)
							s.CalledStateV = append(s.CalledStateV, stVr[0].(string))

							break
						}

					}
					//fmt.Println("====>Function", varbl.GetText())
					//}
				}
				if ctx.FunctionDescriptor().Identifier() != nil {
					if strings.Contains(ctx.FunctionDescriptor().Identifier().GetText(), "balanceOf") && s.Mode == "NoLP" && ctx.Block() != nil {

						for _, stVr := range s.StateVariables {
							if strings.Contains(ctx.Block().GetText(), "return"+stVr[0].(string)) || strings.Contains(ctx.Block().GetText(), "="+stVr[0].(string)) {
								s.BalanceSlotNumber(stVr[2].(int))
								fmt.Println("Current Variable", stVr[0], stVr[2], "Func Name", ctx.FunctionDescriptor().Identifier().GetText(), ctx.Block().GetText(), "Inside FUnction", s.ContractType)
								s.BalaNXSlot = stVr[2].(int)
								break
							}

						}
					}
				}
			}

		}(&s.WaitGroup)
	}

}
func (s *SolidityTreeListener) EnterStateVariableDeclaration(ctx solidityparser.StateVariableDeclarationContext) {
	//rcc := regexp.MustCompile(`^abstractcontract\w+is\w+`)

	if strings.Contains(ctx.GetText(), "constant") == false && strings.Contains(ctx.GetText(), "immutable") == false {
		//fmt.Println("Source", ctx.GetText(), "TypeName:-", ctx.TypeName().GetText(), "Identifier", ctx.Identifier().GetText(), "int", "Inside FUnction", s.ContractType)

		pattern := `(uint\d*|address|bool|string|bytes\d*)\[(\d+)\]`
		patternX := `(uint\d*|address|bool|string|bytes\d*)\[\]`

		r := regexp.MustCompile(pattern)
		rx := regexp.MustCompile(patternX)

		if strings.Contains(ctx.TypeName().GetText(), "mapping") {
			bytestore = 32
			s.TypeNameOfVar = "mapping"
			//slotz += 1
			//fmt.Println("SLot mapping")
			preVarable = "complex"

			//theSlotData(context.Background(), s.Address, slotz, s.Network, s.Client, ctx.TypeName().GetText())
			//slotz += 1
		} else if rx.MatchString(ctx.TypeName().GetText()) {
			bytestore = 32
			//slotz += 1
			preVarable = "complex"
			slotfilled = 0
			s.TypeNameOfVar = "Array[]"
			//fmt.Println("SLot Array[]")
			//Array Length
			//theSlotData(context.Background(), s.Address, slotz, s.Network, s.Client, ctx.TypeName().GetText())

			//Value of Array
			//hexutil.Encode(slotHash))
			//i := common.HexToHash(hexutil.Encode(slotHash))
			//theBigSlotData(context.Background(), s.Address, slotHash, s.Network, s.Client, ctx.TypeName().GetText())
			//slotz += 1
		} else if r.MatchString(ctx.TypeName().GetText()) {
			//bytestore = 0
			//slotz += 1
			slotfilled = 0
			preVarable = "complex"
			//fmt.Println("SLot Array[d]")
			pattern := `(uint\d*|address|bool|string|bytes\d*)\[(\d+)\]`
			s.TypeNameOfVar = "Array[x]"
			r := regexp.MustCompile(pattern)
			match := r.FindStringSubmatch(ctx.TypeName().GetText())

			if len(match) > 2 {
				//dataType := match[1]
				value := match[2]
				//-//fmt.Println("Data Type:", dataType)
				//-//fmt.Println("Value:", value)
				arryN, _ := strconv.Atoi(value)
				staticArray = arryN
			} else {
				//-//fmt.Println("No match found")
			}

		} else if strings.Contains(s.StructStorage, ctx.TypeName().GetText()) {
			s.TypeNameOfVar = "Struct"
			staticArray = s.StructLen
			//-//fmt.Println("Struct Dete", staticArray, s.StructStorage)

		} else {
			if preVarable == "complex" {
				//slotz += 1
				//slotfilled = 0
				//-//fmt.Println("Current Slot:-", slotz)
			}
			s.TypeNameOfVar = "Norm"
			if strings.Contains(ctx.TypeName().GetText(), "uint") {
				pat := `uint(\d+)`
				r := regexp.MustCompile(pat)
				match := r.FindStringSubmatch(ctx.TypeName().GetText())

				if len(match) > 1 {
					dataType, _ := strconv.Atoi(match[1])
					size := math.Ceil(float64(dataType) / float64(8))
					bytestore = int(size)

					preVarable = "single"

					//-//fmt.Println("Data Type:-", bytestore)
				} else {
					//-//fmt.Println("No match found")
					bytestore = 32

					preVarable = "single"

					//slotz += 1
				}
			} else if strings.Contains(ctx.TypeName().GetText(), "bytes") {
				pat := `bytes(\d+)`
				r := regexp.MustCompile(pat)
				match := r.FindStringSubmatch(ctx.TypeName().GetText())

				if len(match) > 1 {
					dataType, _ := strconv.Atoi(match[1])
					size := float64(dataType)
					bytestore = int(size)
					preVarable = "single"
					//-//fmt.Println("Data Type:", bytestore)
				} else {

					bytestore = int(1)
					preVarable = "single"
					//-//fmt.Println("Data Type:", bytestore)
				}
			} else if strings.Contains(ctx.TypeName().GetText(), "bool") {
				bytestore = int(1)
				preVarable = "single"
				//-//fmt.Println("Data Type:", bytestore)
			} else if strings.Contains(ctx.TypeName().GetText(), "string") {
				bytestore = int(32)
				preVarable = "single"
				//-//fmt.Println("Data Type:", bytestore)
			} else {
				bytestore = int(20)
				preVarable = "single"
				//-//fmt.Println("Data Type:", bytestore)

			}

		}

		if s.currentBytes+bytestore <= 32 && staticArray == 0 {
			s.currentSlot = append(s.currentSlot, bytestore)
			s.currentBytes += bytestore
			s.slotarray = append(s.slotarray, slotz)
			//**//theSlotData(context.Background(), s.Address, slotz, s.Network, s.Client, ctx.TypeName().GetText(), s.TypeNameOfVar, s.OwnersAddress)
			varDiscriptor := []any{ctx.Identifier().GetText(), ctx.TypeName().GetText(), slotz, s.TypeNameOfVar, ctx.GetText()}
			s.StateVariables = append(s.StateVariables, varDiscriptor)
		} else if staticArray != 0 {
			var addxx int = 0

			for x := 0; x < staticArray; x++ {
				re := regexp.MustCompile(`\{(.*?)\}`)
				matchhh := re.FindAllStringSubmatch(s.StructStorage, -1)
				strTypNm := strings.Split(matchhh[0][1], ";")
				//-//fmt.Println("Storage:-", strTypNm)

				if strings.Contains(ctx.TypeName().GetText(), "uint") || strings.Contains(strTypNm[x], "uint") {
					pat := `uint(\d+)`
					r := regexp.MustCompile(pat)
					match := r.FindStringSubmatch(ctx.TypeName().GetText())
					matchx := r.FindStringSubmatch(strTypNm[x])
					if len(match) > 1 {
						dataType, _ := strconv.Atoi(match[1])
						size := math.Ceil(float64(dataType) / float64(8))
						bytestore = int(size)

						preVarable = "single"

						//-//fmt.Println("Data Type:-", bytestore)
					} else if len(matchx) > 1 {
						dataType, _ := strconv.Atoi(matchx[1])
						size := math.Ceil(float64(dataType) / float64(8))
						bytestore = int(size)

						preVarable = "single"

						//-//fmt.Println("Data Type:-", bytestore)
					} else {
						//-//fmt.Println("No match found")
						bytestore = 32
						preVarable = "single"

						//slotz += 1
					}

				} else if strings.Contains(ctx.TypeName().GetText(), "bytes") || strings.Contains(strTypNm[x], "bytes") {
					pat := `bytes(\d+)`
					r := regexp.MustCompile(pat)
					match := r.FindStringSubmatch(ctx.TypeName().GetText())
					matchx := r.FindStringSubmatch(strTypNm[x])

					if len(match) > 1 {
						dataType, _ := strconv.Atoi(match[1])
						size := float64(dataType)
						bytestore = int(size)
						preVarable = "single"
						//-//fmt.Println("Data Type:", bytestore)
					} else if len(matchx) > 1 {
						dataType, _ := strconv.Atoi(matchx[1])
						size := math.Ceil(float64(dataType) / float64(8))
						bytestore = int(size)

						preVarable = "single"

						//-//fmt.Println("Data Type:-", bytestore)
					} else {

						bytestore = int(1)
						preVarable = "single"
						//-//fmt.Println("Data Type:", bytestore)
					}

				} else if strings.Contains(ctx.TypeName().GetText(), "bool") || strings.Contains(strTypNm[x], "bool") {

					bytestore = int(1)
					preVarable = "single"
					//-//fmt.Println("Data Type:", bytestore)

				} else if strings.Contains(ctx.TypeName().GetText(), "string") || strings.Contains(strTypNm[x], "string") {

					bytestore = int(32)
					preVarable = "single"
					//-//fmt.Println("Data Type:", bytestore)

				} else if strings.Contains(ctx.TypeName().GetText(), "address") || strings.Contains(strTypNm[x], "address") {

					bytestore = int(20)
					preVarable = "single"
					//-//fmt.Println("Data Type:", bytestore)

				}
				if s.currentBytes+bytestore <= 32 {
					s.currentSlot = append(s.currentSlot, bytestore)
					s.currentBytes += bytestore
					s.slotarray = append(s.slotarray, slotz)
					varDiscriptor := []any{ctx.Identifier().GetText(), ctx.TypeName().GetText(), slotz, s.TypeNameOfVar, ctx.GetText()}
					s.StateVariables = append(s.StateVariables, varDiscriptor)
					//**//theSlotData(context.Background(), s.Address, slotz, s.Network, s.Client, ctx.TypeName().GetText(), s.TypeNameOfVar, s.OwnersAddress)
					addxx += 1
				} else {
					s.result = append(s.result, s.currentSlot)
					s.currentSlot = []int{bytestore}
					s.currentBytes = bytestore
					slotz += 1
					s.slotarray = append(s.slotarray, slotz)
					varDiscriptor := []any{ctx.Identifier().GetText(), ctx.TypeName().GetText(), slotz, s.TypeNameOfVar, ctx.GetText()}
					s.StateVariables = append(s.StateVariables, varDiscriptor)
					//**//theSlotData(context.Background(), s.Address, slotz, s.Network, s.Client, ctx.TypeName().GetText(), s.TypeNameOfVar, s.OwnersAddress)
					addxx += 1
				}

				if addxx >= staticArray {
					break
				}
			}
			staticArray = 0

		} else {
			s.result = append(s.result, s.currentSlot)
			s.currentSlot = []int{bytestore}
			s.currentBytes = bytestore
			slotz += 1
			s.slotarray = append(s.slotarray, slotz)
			varDiscriptor := []any{ctx.Identifier().GetText(), ctx.TypeName().GetText(), slotz, s.TypeNameOfVar, ctx.GetText()}
			s.StateVariables = append(s.StateVariables, varDiscriptor)
			//**//theSlotData(context.Background(), s.Address, slotz, s.Network, s.Client, ctx.TypeName().GetText(), s.TypeNameOfVar, s.OwnersAddress)

		}
		if len(s.currentSlot) > 0 {
			//s.result = append(s.result, s.currentSlot)
		}
		//-//fmt.Println("SLotssss:-", s.result)
		//-//fmt.Println("Slot Arrya:-", s.slotarray)
	} else {
		//-//fmt.Println("===>Constant")
	}
}

func theBigSlotData(ctx context.Context, address string, index common.Hash, network string, client ethclient.Client, decode string, fiat string, dex string, rpcx string, funcName string, stateVar string, bytecodes string, owner string, modex string, balSlot int, wg *sync.WaitGroup, isTradeRpt chan [][]interface{}) {
	defer wg.Done()
	var wgx sync.WaitGroup
	contractAdd := common.HexToAddress(address)

	fmt.Println("Hash of Slot Big", decode)
	storageValue, err := client.StorageAt(ctx, contractAdd, index, nil)
	if err != nil {
		fmt.Println("Error Get Storage", err)
	}

	var DecodeOutput string
	var Slotdata string
	var SlotdataArray []string
	if strings.Contains(decode, "address") || strings.Contains(strings.ToLower(decode), "router") || strings.Contains(strings.ToLower(decode), "dex") {
		//x:= hexutil.Encode(storageValue)
		addressOutp := common.HexToAddress(hexutil.Encode(storageValue))
		DecodeOutput = addressOutp.Hex()

		//Slot Data
		switch {
		case strings.Contains(strings.ToLower(decode), "router"):
			toAddress := common.HexToAddress(dex)
			paddedAddress := common.LeftPadBytes(toAddress.Bytes(), 32)
			Slotdata = hexutil.Encode(paddedAddress)
		case strings.Contains(strings.ToLower(decode), "dex"):
			toAddress := common.HexToAddress(dex)
			paddedAddress := common.LeftPadBytes(toAddress.Bytes(), 32)
			Slotdata = hexutil.Encode(paddedAddress)
		case strings.Contains(decode, "address"):
			toAddress := common.HexToAddress("0x0000000000000000000000000000000000000125")
			paddedAddress := common.LeftPadBytes(toAddress.Bytes(), 32)
			Slotdata = hexutil.Encode(paddedAddress)
		}
	} else if strings.Contains(decode, "uint") {
		bytes := common.FromHex(hexutil.Encode(storageValue))

		// Create a new BigInt value from bytes
		bigInt := new(big.Int).SetBytes(bytes)
		DecodeOutput = strconv.Itoa(int(bigInt.Int64()))

		//SlotData

		uintInput := []string{"1", "10000000000000000000000000000"}
		for _, uintVal := range uintInput {
			amount := new(big.Int)
			amount.SetString(uintVal, 10)
			paddedAmount := common.LeftPadBytes(amount.Bytes(), 32)
			SlotdataArray = append(SlotdataArray, hexutil.Encode(paddedAmount))
		}

	} else if strings.Contains(decode, "string") {
		//decimal, err := strconv.ParseInt(hexutil.Encode(storageValue), 16, 64)
		// Decode the hex-encoded value
		bytes, err := hexutil.Decode(hexutil.Encode(storageValue))
		if err != nil {
			fmt.Println("Invalid hex-encoded value")
			return
		}

		// Convert bytes to string
		str := string(bytes)
		DecodeOutput = str

		//Slot Data
		stringhex := hexutil.Encode([]byte("Random String"))
		lengTh := len(stringhex)
		amountBigInt := big.NewInt(int64(lengTh))
		paddLnth := common.LeftPadBytes(amountBigInt.Bytes(), 32)
		Slotdata = stringhex + hexutil.Encode(paddLnth)

	} else if strings.Contains(decode, "bool") {
		DecodeOutput = hexutil.Encode(storageValue)

		uintInput := []bool{true, false}
		for _, uintVal := range uintInput {
			boolTy, _ := abi.NewType("bool", "bool", nil)
			arguments := abi.Arguments{

				{
					Type: boolTy,
				},
			}
			Boolbytes, _ := arguments.Pack(uintVal)

			SlotdataArray = append(SlotdataArray, hexutil.Encode(Boolbytes))
			fmt.Println("====>Boolean Big DataSlot", hexutil.Encode(Boolbytes))
		}
	} else {
		DecodeOutput = hexutil.Encode(storageValue)

		amount := new(big.Int)
		amount.SetString("0", 10)
		paddedAmount := common.LeftPadBytes(amount.Bytes(), 32)
		Slotdata = hexutil.Encode(paddedAmount)
	}

	fmt.Println("====>address BigSlot", address, "slot", index, "Decoded Output", DecodeOutput, "decode", decode, "New Slot Data", Slotdata)
	wgx.Add(1)
	go func() {
		defer wgx.Done()
		if len(SlotdataArray) > 0 {
			var TradeState [][]any
			for _, SlotdataX := range SlotdataArray {
				fmt.Println("+vV====V===+V")

				isTrade := make(chan []any)
				wgx.Add(1)
				go transferTokenSlot(address, fiat, dex, rpcx, network, index.String(), client, SlotdataX, decode, owner, funcName, stateVar, bytecodes, modex, balSlot, &wgx, isTrade)

				xxx := <-isTrade
				TradeState = append(TradeState, xxx)

			}
			isTradeRpt <- TradeState
		} else {
			var TradeState [][]any
			isTrade := make(chan []any)
			wgx.Add(1)
			go transferTokenSlot(address, fiat, dex, rpcx, network, index.String(), client, Slotdata, decode, owner, funcName, stateVar, bytecodes, modex, balSlot, &wgx, isTrade)
			xxx := <-isTrade
			TradeState = append(TradeState, xxx)
			isTradeRpt <- TradeState

		}
	}()
	wgx.Wait()
}
func theSlotData(ctx context.Context, address string, i int, network string, client ethclient.Client, decode string, typeName string, owner string, fiat string, dex string, rpcx string, funcName string, stateVar string, bytecodes string, modex string, balSlot int, wgx *sync.WaitGroup, isTradeRpt chan [][]any) {
	defer wgx.Done()
	var wg sync.WaitGroup
	switch typeName {
	case "Array[]":
		uint256Ty, _ := abi.NewType("uint256", "uint256", nil)
		arguments := abi.Arguments{

			{
				Type: uint256Ty,
			},
		}
		bytes, _ := arguments.Pack(big.NewInt(int64(i)))
		var buf []byte
		hassh := crypto.Keccak256(bytes)
		buf = hassh
		slotHash := common.HexToHash(hexutil.Encode(buf))

		r := regexp.MustCompile(`(uint\d*|address|bool|string|bytes\d*)\[\]`)
		match := r.FindStringSubmatch(decode)
		fmt.Println("Dynamic Array Data", slotHash, "Type Ayyay")
		if len(match) > 0 {
			fmt.Println("Dynamic Array Data", slotHash, "Type Ayyay", match[0])

			xValue := make(chan [][]any)
			wg.Add(1)
			go theBigSlotData(ctx, address, slotHash, network, client, match[0], fiat, dex, rpcx, funcName, stateVar, bytecodes, owner, modex, balSlot, &wg, xValue)
			xx := <-xValue
			isTradeRpt <- xx
		}
	case "mapping":
		pattern := `mapping\(([^=]+)=>([^)]+)\)`
		r := regexp.MustCompile(pattern)
		match := r.FindStringSubmatch(decode)
		var slotHash common.Hash
		if len(match) > 0 {
			keyType := match[1]
			valueType := match[2]
			fmt.Println("Key type:", keyType)
			fmt.Println("Value type:", valueType)
			switch keyType {
			case "address":
				/*go func(slot int, owner string) {
					//owner := getDeployedOwner(address, network)
					owerAddr := common.HexToAddress(owner)
					uint256Ty, _ := abi.NewType("uint256", "uint256", nil)
					addressTy, _ := abi.NewType("address", "address", nil)

					arguments := abi.Arguments{
						{
							Type: addressTy,
						},

						{
							Type: uint256Ty,
						},
					}
					bytes, _ := arguments.Pack(owerAddr, big.NewInt(int64(slot)))
					var buf []byte
					hassh := crypto.Keccak256(bytes)
					buf = hassh
					slotHashx := common.HexToHash(hexutil.Encode(buf))
					stVal, _ := client.StorageAt(context.Background(), common.HexToAddress(owner), slotHashx, nil)
					fmt.Println("Storage Value", hexutil.Encode(stVal), "owner", owner, "Slot", slot)
				}(i, owner)*/
				owerAddr := common.HexToAddress("0x0000000000000000000000000000000000000125")
				uint256Ty, _ := abi.NewType("uint256", "uint256", nil)
				addressTy, _ := abi.NewType("address", "address", nil)

				arguments := abi.Arguments{
					{
						Type: addressTy,
					},

					{
						Type: uint256Ty,
					},
				}
				bytes, _ := arguments.Pack(owerAddr, big.NewInt(int64(i)))
				var buf []byte
				hassh := crypto.Keccak256(bytes)
				buf = hassh
				slotHash = common.HexToHash(hexutil.Encode(buf))
				fmt.Println("Dynamic Array Data", slotHash, "Address", owerAddr, "Init Slot", i)
			}

			fmt.Println("Dynamic Array Data", slotHash)

			xValue := make(chan [][]any)
			wg.Add(1)
			go theBigSlotData(ctx, address, slotHash, network, client, valueType, fiat, dex, rpcx, funcName, stateVar, bytecodes, owner, modex, balSlot, &wg, xValue)
			xx := <-xValue
			isTradeRpt <- xx
		} else {
			fmt.Println("No match found")
		}

	default:

		contractAdd := common.HexToAddress(address)
		z := big.NewInt(int64(i))
		index := common.BigToHash(z)
		fmt.Println("Hash of Slot", index)
		storageValue, err := client.StorageAt(ctx, contractAdd, index, nil)
		if err != nil {
			fmt.Println("Error Get Storage", err)
		}

		//decimalValue := new(big.Int).SetBytes(storageValue).String()
		var DecodeOutput string
		var Slotdata string
		var SlotdataArray []string
		if strings.Contains(decode, "address") || strings.Contains(strings.ToLower(decode), "router") || strings.Contains(strings.ToLower(decode), "dex") {
			//x:= hexutil.Encode(storageValue)
			addressOutp := common.HexToAddress(hexutil.Encode(storageValue))
			DecodeOutput = addressOutp.Hex()

			//Slot Data
			switch {
			case strings.Contains(strings.ToLower(decode), "router"):
				toAddress := common.HexToAddress(dex)
				paddedAddress := common.LeftPadBytes(toAddress.Bytes(), 32)
				Slotdata = hexutil.Encode(paddedAddress)
			case strings.Contains(strings.ToLower(decode), "dex"):
				toAddress := common.HexToAddress(dex)
				paddedAddress := common.LeftPadBytes(toAddress.Bytes(), 32)
				Slotdata = hexutil.Encode(paddedAddress)
			case strings.Contains(decode, "address"):
				toAddress := common.HexToAddress("0x0000000000000000000000000000000000000125")
				paddedAddress := common.LeftPadBytes(toAddress.Bytes(), 32)
				Slotdata = hexutil.Encode(paddedAddress)
			}
		} else if strings.Contains(decode, "uint") {
			bytes := common.FromHex(hexutil.Encode(storageValue))

			// Create a new BigInt value from bytes
			bigInt := new(big.Int).SetBytes(bytes)
			DecodeOutput = strconv.Itoa(int(bigInt.Int64()))

			//SlotData

			/*amount := new(big.Int)
			amount.SetString("1000000000000000000000", 10)
			paddedAmount := common.LeftPadBytes(amount.Bytes(), 32)
			Slotdata = hexutil.Encode(paddedAmount)*/
			uintInput := []string{"1", "10000000000000000000000000000"}
			for _, uintVal := range uintInput {
				amount := new(big.Int)
				amount.SetString(uintVal, 10)
				paddedAmount := common.LeftPadBytes(amount.Bytes(), 32)
				SlotdataArray = append(SlotdataArray, hexutil.Encode(paddedAmount))
			}
		} else if strings.Contains(decode, "string") {
			//decimal, err := strconv.ParseInt(hexutil.Encode(storageValue), 16, 64)
			// Decode the hex-encoded value
			bytes, err := hexutil.Decode(hexutil.Encode(storageValue))
			if err != nil {
				fmt.Println("Invalid hex-encoded value")
				return
			}

			// Convert bytes to string
			str := string(bytes)
			DecodeOutput = str

			//Slot Data
			stringhex := hexutil.Encode([]byte("Random String"))
			lengTh := len(stringhex)
			amountBigInt := big.NewInt(int64(lengTh))
			paddLnth := common.LeftPadBytes(amountBigInt.Bytes(), 32)
			Slotdata = stringhex + hexutil.Encode(paddLnth)

		} else if strings.Contains(decode, "bool") {
			DecodeOutput = hexutil.Encode(storageValue)

			//SlotData
			/*
				amount := new(big.Int)
				amount.SetString("0", 10)
				paddedAmount := common.LeftPadBytes(amount.Bytes(), 32)
				Slotdata = hexutil.Encode(paddedAmount)

				boolTy, _ := abi.NewType("bool", "bool", nil)
				arguments := abi.Arguments{

					{
						Type: boolTy,
					},
				}
				Boolbytes, _ := arguments.Pack(true)
				paddedBool := common.LeftPadBytes(Boolbytes, 32)
				fmt.Println("====>Boolean DataSlot", hexutil.Encode(paddedBool))*/
			uintInput := []bool{true, false}
			for _, uintVal := range uintInput {
				boolTy, _ := abi.NewType("bool", "bool", nil)
				arguments := abi.Arguments{

					{
						Type: boolTy,
					},
				}
				Boolbytes, _ := arguments.Pack(uintVal)

				SlotdataArray = append(SlotdataArray, hexutil.Encode(Boolbytes))
				fmt.Println("====>Boolean Big DataSlot", hexutil.Encode(Boolbytes))
			}
		} else {
			DecodeOutput = hexutil.Encode(storageValue)

			//SlotData
			//0x0000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e0001
			//0x0000000000000000000000000000000000000000000000000000000000000000
			//0x0000000000000000000000000000000000000000000000000000000000000001
			amount := new(big.Int)
			amount.SetString("0", 10)
			paddedAmount := common.LeftPadBytes(amount.Bytes(), 32)
			Slotdata = hexutil.Encode(paddedAmount)
		}
		fmt.Println("====>address", address, "slot", i, "Decoded Output", DecodeOutput, "decode", decode, "TypeNameofVar", typeName, "Function Name", funcName, "Slot Data", Slotdata)
		wg.Add(1)
		go func() {
			defer wg.Done()
			if len(SlotdataArray) > 0 {
				var TradeState [][]any
				for _, SlotdataX := range SlotdataArray {
					fmt.Println("====V===+V")
					isTrade := make(chan []any)
					var FunCRPT []interface{}
					FunCRPT = append(FunCRPT, funcName)
					wg.Add(1)
					go transferTokenSlot(address, fiat, dex, rpcx, network, index.String(), client, SlotdataX, decode, owner, funcName, stateVar, bytecodes, modex, balSlot, &wg, isTrade)
					x := <-isTrade
					TradeState = append(TradeState, x)

				}
				isTradeRpt <- TradeState
			} else {
				var TradeState [][]any
				isTrade := make(chan []any)
				var FunCRPT []interface{}
				FunCRPT = append(FunCRPT, funcName)
				wg.Add(1)
				go transferTokenSlot(address, fiat, dex, rpcx, network, index.String(), client, Slotdata, decode, owner, funcName, stateVar, bytecodes, modex, balSlot, &wg, isTrade)

				x := <-isTrade
				TradeState = append(TradeState, x)
				isTradeRpt <- TradeState

			}
		}()
	}
	wg.Wait()
}
func getStorageSlot(ctx context.Context, address string, fiat string, dex string, rpcx string, network string, client ethclient.Client, bytecodes string, mode string, tradeMode string, slotzBl int, wgx *sync.WaitGroup, ruleNameChan chan [][]any) {
	defer wgx.Done()
	sourceCode := getSourceCode(address, network)
	//fmt.Println("Source Code:", sourceCode)
	if sourceCode != "Not Verified" {
		code := antlr.NewInputStream(sourceCode)
		lexer := solidityparser.NewSolidityLexer(code)
		stream := antlr.NewCommonTokenStream(lexer, antlr.TokenDefaultChannel)

		p := solidityparser.NewSolidityParser(stream)

		//p.AddErrorListener(antlr.NewDiagnosticErrorListener(true))
		//ruleNameChan := make(chan [][]any, 100)
		var ruleNameXX [][]any
		var bal int
		p.BuildParseTrees = true

		tree := p.SourceUnit()
		listener := SolidityTreeListener{}
		listener.Fiat = fiat
		listener.Dex = dex
		listener.RPCX = rpcx
		listener.Address = address
		listener.Network = network
		listener.Client = client
		listener.currentBytes = 0
		listener.TypeNameOfVar = ""
		listener.OwnersAddress = getDeployedOwner(address, network)
		listener.StateVariables = [][]any{}
		listener.ByteCodes = bytecodes
		listener.CalledStateV = []string{}
		listener.Report = [][]any{}
		listener.ChannelReport = func(ruleName [][]any) { ruleNameXX = ruleName }
		listener.Mode = mode
		listener.BalanceSlotNumber = func(i int) { bal = i }
		listener.ContractType = ""
		listener.BalaNXSlot = slotzBl
		listener.TradeMode = tradeMode
		//listener.RuleMIndex =
		slotz = 0
		bytestore = 0
		slotfilled = 0
		staticArray = 0
		preVarable = "simple"
		antlr.ParseTreeWalkerDefault.Walk(&listener, tree)

		listener.WaitGroup.Wait()

		if mode == "" {
			ruleNameChan <- ruleNameXX
		} else {
			ruleNameChan <- [][]any{{bal}}

		}
	} else {
		ruleNameChan <- [][]any{{"Not Verified"}}
	}
}
func transferTokenDirect(tokenad string, fiat string, dex string, rpcx string, network string, client ethclient.Client, _byteCodes string, wgx *sync.WaitGroup, txt chan []any) {
	defer wgx.Done()
	fmt.Println("RPC=========", tokenad, ",", fiat, ",", dex)
	clientrpc, err := rpc.DialHTTP(rpcx)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println(rpcx)
	defer clientrpc.Close()

	var theowner string
	theowner = getDeployedOwner(tokenad, network)
	fmt.Println(theowner)

	abiFreeJson := "[{\"inputs\": [ {\"internalType\": \"address\",\"name\": \"_tokenIn\",\"type\": \"address\" }, {\"internalType\": \"address\",\"name\": \"_tokenOut\",\"type\": \"address\"},{\"internalType\": \"string\",\"name\": \"network\",\"type\": \"string\"}, {\"internalType\": \"uint256\",\"name\": \"amountOutMin\",\"type\": \"uint256\"},{\"internalType\": \"address\",\"name\": \"UNISWAP_ROUTER\",\"type\": \"address\"}],\"name\": \"testTokenSwap\",\"outputs\": [{\"internalType\": \"uint256\",\"name\": \"\", \"type\": \"uint256\"},{\"internalType\": \"uint256\", \"name\": \"\",\"type\": \"uint256\"}],\"stateMutability\": \"payable\",\"type\": \"function\",\"payable\": true}]"
	//\"outputs\": [{\"internalType\": \"uint256[]\",\"name\": \"\",\"type\": \"uint256[]\"}]

	tokenAddress := common.HexToAddress(tokenad)
	fiatAddress := common.HexToAddress(fiat)
	dexrouter := common.HexToAddress(dex)
	amountOutmin := big.NewInt(0)
	parsedAbi, err := abi.JSON(strings.NewReader(abiFreeJson)) //(abiJson))
	if err != nil {
		panic(err)
	}
	trx, err := parsedAbi.Pack("testTokenSwap", fiatAddress, tokenAddress, network, amountOutmin, dexrouter)

	type request struct {
		From  string `json:"from"`
		To    string `json:"to"`
		Value string `json:"value"`
		Data  string `json:"data"`
	}
	type getBal struct {
		From string `json:"from"`
		Data string `json:"data"`
	}

	var result interface{}

	// Execute the contract method call with state override
	amount := new(big.Int)
	amount.SetString("1000000000000", 10)
	vall := hexutil.Encode(amount.Bytes())
	fmt.Println("Value::---", vall)
	req := request{"0x0000000000000000000000000000000000000124", "0x0000000000000000000000000000000000000125", hexutil.Encode(amount.Bytes()), hexutil.Encode(trx)}
	bal := new(big.Int)
	bal.SetString("1000000000000000000000", 10)

	byteCode := _byteCodes
	//bytecodeHash := common.HexToHash(byteCode)

	_stateDiff := map[string]interface{}{
		"0x0000000000000000000000000000000000000124": map[string]interface{}{
			"balance": hexutil.Encode(bal.Bytes()),
		},
		"0x0000000000000000000000000000000000000125": map[string]interface{}{
			"code": byteCode,
		},
	}
	stOvrrd := _stateDiff

	var errrr error
	if err := clientrpc.Call(&result, "eth_call", req, "latest", stOvrrd); err != nil {
		fmt.Println("Error Call", err, errrr)
	}

	type Result struct {
		Values []*big.Int
	}
	fmt.Println("Reeesssult", result, "Func NAme")
	if result != nil {
		resultBytes, err := hexutil.Decode(result.(string))
		if err != nil {
			panic(err)
		}
		reslt := make([]*big.Int, len(resultBytes)/64)
		for i := 0; i < len(reslt); i++ {
			reslt[i] = new(big.Int).SetBytes(resultBytes[i*64 : (i+1)*64])
		}
		outputBytes := common.FromHex(result.(string))
		offset := 64 // Assuming each uint takes 32 bytes in the output

		fmt.Println("outputBytes", outputBytes, result.(string))
		outputt, err := parsedAbi.Unpack("testTokenSwap", outputBytes)
		if err != nil {
			log.Fatal(err)
		}
		var taxes [2]*big.Int
		for i := 0; i < 2; i++ {
			taxes[i] = new(big.Int).SetBytes(outputBytes[offset*i : offset*(i+1)])
			fmt.Println(offset*i, offset*(i+1), result.(string)[offset*i:offset*(i+1)])
		}
		z := big.NewInt(int64(0))
		index := common.BigToHash(z)
		fmt.Println("Real RPC Result===", outputt, "Slot @:-", index)
		txt <- outputt
	} else {
		txt <- []any{big.NewInt(1000), big.NewInt(1000)}
	}

}
func transferTokenDirectNoLP(tokenad string, fiat string, dex string, rpcx string, network string, client ethclient.Client, _byteCodes string, slot int, wgx *sync.WaitGroup, txt chan []any) {
	defer wgx.Done()
	fmt.Println("RPC=========", tokenad, ",", fiat, ",", dex)
	clientrpc, err := rpc.DialHTTP(rpcx) //("http://127.0.0.1:8545") //(rpcx)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println(rpcx)
	defer clientrpc.Close()

	var theowner string
	theowner = getDeployedOwner(tokenad, network)
	fmt.Println(theowner)

	abiFreeJson := "[{\"inputs\": [{\"internalType\": \"address\", \"name\": \"_tokenIn\", \"type\": \"address\"}, {\"internalType\": \"address\", \"name\": \"_tokenOut\", \"type\": \"address\"}, {\"internalType\": \"string\", \"name\": \"network\", \"type\": \"string\"}, {\"internalType\": \"uint256\", \"name\": \"amountOutMin\", \"type\": \"uint256\"}, {\"internalType\": \"uint256\", \"name\": \"amountIn\", \"type\": \"uint256\"}, {\"internalType\": \"address\", \"name\": \"UNISWAP_ROUTER\", \"type\": \"address\"}], \"name\": \"testTokenSwapNoLp\", \"outputs\": [{\"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\"}, {\"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\"}], \"stateMutability\": \"payable\", \"type\": \"function\"}]"

	//\"outputs\": [{\"internalType\": \"uint256[]\",\"name\": \"\",\"type\": \"uint256[]\"}]

	tokenAddress := common.HexToAddress(tokenad)
	fiatAddress := common.HexToAddress(fiat)
	dexrouter := common.HexToAddress(dex)
	amountOutmin := big.NewInt(0)
	amountIn := new(big.Int)
	amountIn.SetString("50000000000000", 10)                   //1000000000000000000000000
	parsedAbi, err := abi.JSON(strings.NewReader(abiFreeJson)) //(abiJson))
	if err != nil {
		panic(err)
	}
	trx, err := parsedAbi.Pack("testTokenSwapNoLp", fiatAddress, tokenAddress, network, amountOutmin, amountIn, dexrouter)

	type request struct {
		From  string `json:"from"`
		To    string `json:"to"`
		Value string `json:"value"`
		Data  string `json:"data"`
	}
	type getBal struct {
		From string `json:"from"`
		Data string `json:"data"`
	}

	var result interface{}

	// Execute the contract method call with state override
	amount := new(big.Int)
	amount.SetString("100000000000000", 10) //amount.SetString("1000000000000000000", 10)
	req := request{"0x0000000000000000000000000000000000000124", "0x0000000000000000000000000000000000000125", hexutil.Encode(amount.Bytes()), hexutil.Encode(trx)}
	bal := new(big.Int)
	bal.SetString("1000000000000000000000", 10)

	byteCode := _byteCodes
	//bytecodeHash := common.HexToHash(byteCode)

	owerAddr := common.HexToAddress("0x0000000000000000000000000000000000000125")
	uint256Ty, _ := abi.NewType("uint256", "uint256", nil)
	addressTy, _ := abi.NewType("address", "address", nil)

	arguments := abi.Arguments{
		{
			Type: addressTy,
		},

		{
			Type: uint256Ty,
		},
	}
	bytes, _ := arguments.Pack(owerAddr, big.NewInt(int64(slot)))
	var buf []byte
	hassh := crypto.Keccak256(bytes)
	buf = hassh
	slotHash := common.HexToHash(hexutil.Encode(buf))

	amountx := new(big.Int)
	amountx.SetString("10000000000000000000000000", 10)
	paddedAmount := common.LeftPadBytes(amountx.Bytes(), 32)
	Slotdata := hexutil.Encode(paddedAmount)
	//1000000000000000000000000000000

	storageValue, err := client.StorageAt(context.Background(), common.HexToAddress(tokenad), slotHash, nil)

	bytesx := common.FromHex(hexutil.Encode(storageValue))

	// Create a new BigInt value from bytes
	bigInt := new(big.Int).SetBytes(bytesx)
	DecodeOutput := strconv.Itoa(int(bigInt.Int64()))
	fmt.Println("SLot Data", DecodeOutput, Slotdata)

	if err != nil {
		fmt.Println("Error Get Storage", err)
	}
	_stateDiff := map[string]interface{}{
		"0x0000000000000000000000000000000000000124": map[string]interface{}{
			"balance": hexutil.Encode(bal.Bytes()),
		},
		tokenAddress.String(): map[string]interface{}{

			"stateDiff": map[string]string{
				slotHash.String(): Slotdata,
			},
		},
		"0x0000000000000000000000000000000000000125": map[string]interface{}{
			"code": byteCode,
		},
	}
	stOvrrd := _stateDiff

	var errrr error
	if err := clientrpc.Call(&result, "eth_call", req, "latest", stOvrrd); err != nil {
		fmt.Println("Error Call", err, errrr)
	}

	type Result struct {
		Values []*big.Int
	}
	fmt.Println("Reeesssult", result, "Func NAme", dexrouter)
	if result != nil {
		resultBytes, err := hexutil.Decode(result.(string))
		if err != nil {
			panic(err)
		}
		reslt := make([]*big.Int, len(resultBytes)/64)
		for i := 0; i < len(reslt); i++ {
			reslt[i] = new(big.Int).SetBytes(resultBytes[i*64 : (i+1)*64])
		}
		outputBytes := common.FromHex(result.(string))
		offset := 64 // Assuming each uint takes 32 bytes in the output

		fmt.Println("outputBytes", outputBytes, result.(string))
		outputt, err := parsedAbi.Unpack("testTokenSwapNoLp", outputBytes)
		if err != nil {
			log.Fatal(err)
		}
		var taxes [2]*big.Int
		for i := 0; i < 2; i++ {
			taxes[i] = new(big.Int).SetBytes(outputBytes[offset*i : offset*(i+1)])
			fmt.Println(offset*i, offset*(i+1), result.(string)[offset*i:offset*(i+1)])
		}
		z := big.NewInt(int64(0))
		index := common.BigToHash(z)
		fmt.Println("Real RPC Result===", outputt, "Slot @:-", index)
		txt <- outputt
	} else {
		txt <- []any{big.NewInt(1000), big.NewInt(1000)}
	}

}
func transferTokenSlot(tokenad string, fiat string, dex string, rpcx string, network string, slot string, client ethclient.Client, Slotdata string, decode string, owner string, funcName string, stateVar string, _byteCodes string, mode string, slotz int, wg *sync.WaitGroup, txt chan []any) {
	defer wg.Done()
	fmt.Println("======> State Override", tokenad, ",", fiat, ",", dex, ",=====>Decode", decode, "=====<> Owner NAme", owner, "\n_____________Mode:-", mode, "Loatsz", slotz, "Slot", slot)
	clientrpc, err := rpc.DialHTTP(rpcx) //("http://127.0.0.1:8545") //(rpcx)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println(rpcx)
	defer clientrpc.Close()

	var theowner string
	theowner = owner //getDeployedOwner(tokenad, network)
	fmt.Println(theowner)
	if mode == "NoLP" {
		fmt.Println("LP No ADDED")
		abiFreeJson := "[{\"inputs\": [{\"internalType\": \"address\", \"name\": \"_tokenIn\", \"type\": \"address\"}, {\"internalType\": \"address\", \"name\": \"_tokenOut\", \"type\": \"address\"}, {\"internalType\": \"string\", \"name\": \"network\", \"type\": \"string\"}, {\"internalType\": \"uint256\", \"name\": \"amountOutMin\", \"type\": \"uint256\"}, {\"internalType\": \"uint256\", \"name\": \"amountIn\", \"type\": \"uint256\"}, {\"internalType\": \"address\", \"name\": \"UNISWAP_ROUTER\", \"type\": \"address\"}], \"name\": \"testTokenSwapNoLp\", \"outputs\": [{\"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\"}, {\"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\"}], \"stateMutability\": \"payable\", \"type\": \"function\"}]"

		//\"outputs\": [{\"internalType\": \"uint256[]\",\"name\": \"\",\"type\": \"uint256[]\"}]

		tokenAddress := common.HexToAddress(tokenad)
		fiatAddress := common.HexToAddress(fiat)
		dexrouter := common.HexToAddress(dex)
		amountOutmin := big.NewInt(0)
		amountIn := new(big.Int)
		amountIn.SetString("50000000000000", 10)                   //1000000000000000000000000
		parsedAbi, err := abi.JSON(strings.NewReader(abiFreeJson)) //(abiJson))
		if err != nil {
			panic(err)
		}
		trx, err := parsedAbi.Pack("testTokenSwapNoLp", fiatAddress, tokenAddress, network, amountOutmin, amountIn, dexrouter)

		type request struct {
			From  string `json:"from"`
			To    string `json:"to"`
			Value string `json:"value"`
			Data  string `json:"data"`
		}
		type getBal struct {
			From string `json:"from"`
			Data string `json:"data"`
		}

		var result interface{}

		// Execute the contract method call with state override
		amount := new(big.Int)
		amount.SetString("100000000000000", 10) //amount.SetString("10000000000000000", 10)
		vall := hexutil.Encode(amount.Bytes())
		fmt.Println("Value::---", vall)
		req := request{"0x0000000000000000000000000000000000000124", "0x0000000000000000000000000000000000000125", vall, hexutil.Encode(trx)}
		bal := new(big.Int)
		bal.SetString("1000000000000000000000", 10)

		byteCode := _byteCodes
		//bytecodeHash := common.HexToHash(byteCode)

		owerAddr := common.HexToAddress("0x0000000000000000000000000000000000000125")
		uint256Ty, _ := abi.NewType("uint256", "uint256", nil)
		addressTy, _ := abi.NewType("address", "address", nil)

		arguments := abi.Arguments{
			{
				Type: addressTy,
			},

			{
				Type: uint256Ty,
			},
		}
		bytes, _ := arguments.Pack(owerAddr, big.NewInt(int64(slotz)))
		var buf []byte
		hassh := crypto.Keccak256(bytes)
		buf = hassh
		slotHash := common.HexToHash(hexutil.Encode(buf))

		amountx := new(big.Int)
		amountx.SetString("10000000000000000000000000", 10)
		paddedAmount := common.LeftPadBytes(amountx.Bytes(), 32)
		SlotdataX := hexutil.Encode(paddedAmount)
		//1000000000000000000000000000000

		if err != nil {
			fmt.Println("Error Get Storage", err)
		}
		_stateDiff := map[string]interface{}{
			"0x0000000000000000000000000000000000000124": map[string]interface{}{
				"balance": hexutil.Encode(bal.Bytes()),
			},
			tokenAddress.String(): map[string]interface{}{

				"stateDiff": map[string]string{
					slotHash.String(): SlotdataX,
					slot:              Slotdata,
				},
			},
			"0x0000000000000000000000000000000000000125": map[string]interface{}{
				"code": byteCode,
			},
		}
		stOvrrd := _stateDiff

		var errrr error
		if err := clientrpc.Call(&result, "eth_call", req, "latest", stOvrrd); err != nil {
			fmt.Println("Error Call", err, errrr)
		}

		type Result struct {
			Values []*big.Int
		}
		fmt.Println("Reeesssult", result, "Func NAme", dexrouter)
		if result != nil {
			resultBytes, err := hexutil.Decode(result.(string))
			if err != nil {
				panic(err)
			}
			reslt := make([]*big.Int, len(resultBytes)/64)
			for i := 0; i < len(reslt); i++ {
				reslt[i] = new(big.Int).SetBytes(resultBytes[i*64 : (i+1)*64])
			}
			outputBytes := common.FromHex(result.(string))
			offset := 64 // Assuming each uint takes 32 bytes in the output

			fmt.Println("outputBytes", outputBytes, result.(string))
			outputt, err := parsedAbi.Unpack("testTokenSwapNoLp", outputBytes)
			if err != nil {
				log.Fatal(err)
			}
			var taxes [2]*big.Int
			for i := 0; i < 2; i++ {
				taxes[i] = new(big.Int).SetBytes(outputBytes[offset*i : offset*(i+1)])
				fmt.Println(offset*i, offset*(i+1), result.(string)[offset*i:offset*(i+1)])
			}
			z := big.NewInt(int64(0))
			index := common.BigToHash(z)
			fmt.Println("Real RPC Result===", outputt, "Slot @:-", index)
			buyTxt := outputt[0].(*big.Int)
			sellTxt := outputt[1].(*big.Int)
			if (buyTxt.Cmp(big.NewInt(300)) < 0) && (sellTxt.Cmp(big.NewInt(300)) < 0) {
				txt <- []any{"GOOD"}
			} else {
				txt <- []any{"Empty"}
			}
		} else {
			txt <- []any{"Empty"}
		}
	} else {
		fmt.Println("LP ADDED", Slotdata)
		abiFreeJson := "[{\"inputs\": [ {\"internalType\": \"address\",\"name\": \"_tokenIn\",\"type\": \"address\" }, {\"internalType\": \"address\",\"name\": \"_tokenOut\",\"type\": \"address\"},{\"internalType\": \"string\",\"name\": \"network\",\"type\": \"string\"}, {\"internalType\": \"uint256\",\"name\": \"amountOutMin\",\"type\": \"uint256\"},{\"internalType\": \"address\",\"name\": \"UNISWAP_ROUTER\",\"type\": \"address\"}],\"name\": \"testTokenSwap\",\"outputs\": [{\"internalType\": \"uint256\",\"name\": \"\", \"type\": \"uint256\"},{\"internalType\": \"uint256\", \"name\": \"\",\"type\": \"uint256\"}],\"stateMutability\": \"payable\",\"type\": \"function\",\"payable\": true}]"
		//\"outputs\": [{\"internalType\": \"uint256[]\",\"name\": \"\",\"type\": \"uint256[]\"}]

		tokenAddress := common.HexToAddress(tokenad)
		fiatAddress := common.HexToAddress(fiat)
		dexrouter := common.HexToAddress(dex)
		amountOutmin := big.NewInt(0)
		parsedAbi, err := abi.JSON(strings.NewReader(abiFreeJson)) //(abiJson))
		if err != nil {
			panic(err)
		}
		trx, err := parsedAbi.Pack("testTokenSwap", fiatAddress, tokenAddress, network, amountOutmin, dexrouter)

		type request struct {
			From  string `json:"from"`
			To    string `json:"to"`
			Value string `json:"value"`
			Data  string `json:"data"`
		}
		type getBal struct {
			From string `json:"from"`
			Data string `json:"data"`
		}

		var result interface{}

		// Execute the contract method call with state override
		amount := new(big.Int)
		amount.SetString("10000000000000000", 10)
		req := request{"0x0000000000000000000000000000000000000124", "0x0000000000000000000000000000000000000125", hexutil.Encode(amount.Bytes()), hexutil.Encode(trx)}
		bal := new(big.Int)
		bal.SetString("1000000000000000000000", 10)
		addrToken := common.HexToAddress(tokenad)
		byteCode := _byteCodes
		//bytecodeHash := common.HexToHash(byteCode)

		_stateDiff := map[string]interface{}{
			"0x0000000000000000000000000000000000000124": map[string]interface{}{
				"balance": hexutil.Encode(bal.Bytes()),
			},
			addrToken.String(): map[string]interface{}{
				"stateDiff": map[string]string{
					slot: Slotdata,
				},
			},
			"0x0000000000000000000000000000000000000125": map[string]interface{}{
				"code": byteCode,
			},
		}

		stOvrrd := _stateDiff //tateOverride{stVl}

		fmt.Println("Trx", req, "\nfuncName", funcName, "\n_____________", addrToken)

		var errrr error
		if err := clientrpc.Call(&result, "eth_call", req, "latest", stOvrrd); err != nil {
			fmt.Println("Error Call", err, errrr)
		}
		fmt.Println("Reeesssult", result, "Func NAme", funcName, "Variable Name", stateVar, "Slot:-", slot, "Slot Data", Slotdata)
		type Result struct {
			Values []*big.Int
		}
		if result != nil {
			resultBytes, err := hexutil.Decode(result.(string))
			if err != nil {
				fmt.Println("Err", result)
			}
			reslt := make([]*big.Int, len(resultBytes)/64)
			for i := 0; i < len(reslt); i++ {
				reslt[i] = new(big.Int).SetBytes(resultBytes[i*64 : (i+1)*64])
			}
			outputBytes := common.FromHex(result.(string))
			offset := 64 // Assuming each uint takes 32 bytes in the output

			//fmt.Println("outputBytes", outputBytes, result.(string))
			outputt, err := parsedAbi.Unpack("testTokenSwap", outputBytes)
			if err != nil {
				log.Fatal(err)
			}
			var taxes [2]*big.Int
			for i := 0; i < 2; i++ {
				taxes[i] = new(big.Int).SetBytes(outputBytes[offset*i : offset*(i+1)])
				fmt.Println(offset*i, offset*(i+1), result.(string)[offset*i:offset*(i+1)])
			}

			buyTxt := outputt[0].(*big.Int)
			sellTxt := outputt[1].(*big.Int)
			fmt.Println("RPC Result XX===", outputt, "Slot @:-", slot, "Func NAme", funcName, "Slot Data", Slotdata, "\n_____________", buyTxt, sellTxt, sellTxt.Cmp(big.NewInt(300)), buyTxt.Cmp(big.NewInt(300)))
			if (buyTxt.Cmp(big.NewInt(300)) < 0) && (sellTxt.Cmp(big.NewInt(300)) < 0) {
				txt <- []any{"GOOD"}
			} else {
				txt <- []any{"Empty"}
			}

		} else {
			txt <- []any{"Empty"}
		}
	}
}
func removeLeadingZero(hexString string) string {
	// Remove leading zeros
	hexString = strings.TrimPrefix(hexString, "0x")
	hexString = strings.TrimLeft(hexString, "0")

	// Add "0x" prefix back
	hexString = "0x" + hexString

	return hexString
}
func transferToken(tokenad string, rpcx string, network string, client ethclient.Client) {

	fmt.Println("RPC=========")

	clientrpc, err := rpc.DialHTTP("https://bsc-dataseed1.binance.org/") //("https://mainnet.infura.io/v3/56bb53b84c2e439fa277c9e6522044fe")
	if err != nil {
		log.Fatal(err)
	}
	defer clientrpc.Close()

	type request struct {
		To   string `json:"to"`
		Data string `json:"data"`
	}
	type stateValues struct {
		Balance string `json:"balance"`
	}
	type stateOverride struct {
		Address stateValues `json:"0xB0A478255452F7D7401dE860415cC1038113a8eA"`
	}
	bal := new(big.Int)
	bal.SetString("1000000000000000000000", 10)
	stVl := stateValues{hexutil.Encode(bal.Bytes())}
	stOvrrd := stateOverride{stVl}
	var result string

	req := request{"0xdadfd5d4b8bbc893a5ec43519979b7c579cc4402", "0x8da5cb5b"}
	fmt.Println("Transcation", req)
	if err := clientrpc.Call(&result, "eth_call", req, "latest", stOvrrd); err != nil {
		log.Fatal(err)
	}

	owner := common.HexToAddress(result)
	fmt.Printf("RPC Result===  %s\n", owner.Hex()) // 0x281017b4E914b79371d62518b17693B36c7a221e

}
func getTokenBalance(tokenAdd common.Address, msgSender common.Address, client ethclient.Client) float64 {

	erc20instance, err := erc20.NewERC20Token(tokenAdd, &client)
	if err != nil {
		fmt.Println("Erc Instance Error:", err)
	}
	decimal, err := erc20instance.Decimals(&bind.CallOpts{})
	if err != nil {
		fmt.Println("Decimal Error:", err)
	}
	liquidty, err := erc20instance.BalanceOf(&bind.CallOpts{}, msgSender)
	if err != nil {
		fmt.Println("Liquidity Error:", err)
	}
	valFunc := func() big.Float {

		if liquidty.Cmp(big.NewInt(0)) > 0 {
			return *(new(big.Float).Quo(big.NewFloat(0).SetInt(liquidty), big.NewFloat(0).SetInt(big.NewInt(int64(math.Pow(10, float64(decimal)))))))
		}
		return *big.NewFloat(0)
	}
	val := valFunc()
	res, _ := val.Float64()
	return res
}
func convertToUsdt(tokenAddress string, dex string, network string, client *ethclient.Client) ([]*big.Int, int, error) {
	var USDT string
	var decimal int
	switch network {
	case "BSC":
		USDT = "0x55d398326f99059fF775485246999027B3197955"
		decimal = 18
	case "ETH":
		USDT = "0xdAC17F958D2ee523a2206206994597C13D831ec7"
		decimal = 6
	}
	router := common.HexToAddress(dex)
	based := common.HexToAddress(USDT)
	from := common.HexToAddress(tokenAddress)
	routCnt, err := pancakerouter.NewPancakerouter(router, client)

	if err != nil {
		return nil, -1, err
	}

	// Get the reserves of the token and WBNB in the PancakeSwap liquidity pool
	reserves, err := routCnt.GetAmountsOut(&bind.CallOpts{}, big.NewInt(1000000000000000000), []common.Address{from, based})
	if err != nil {
		return nil, -1, err
	}

	// Calculate the current price of the token in WBNB

	// Return the price as a *big.Float
	return reserves, decimal, nil
}
func getCurrentTokenPrice(tokenAddress string, pair string, client *ethclient.Client) (*big.Float, error) {

	pairAddress := common.HexToAddress(pair)

	pairCntr, err := pancakepair.NewPancakePair(pairAddress, client)

	if err != nil {
		return nil, err
	}

	// Get the reserves of the token and WBNB in the PancakeSwap liquidity pool
	reserves, err := pairCntr.GetReserves(&bind.CallOpts{})
	if err != nil {
		return nil, err
	}

	// Calculate the current price of the token in WBNB
	tokenReserve := new(big.Float).SetInt(reserves.Reserve0)
	WBNBReserve := new(big.Float).SetInt(reserves.Reserve1)
	price := new(big.Float).Quo(WBNBReserve, tokenReserve)

	// Return the price as a *big.Float
	return price, nil
}
func whichDEX(token string, network string, client ethclient.Client, wgx *sync.WaitGroup, pInf chan string) {
	defer wgx.Done()
	var dexRouter []string
	var dexFactory []string
	var label []string
	var fiat []string
	var fiatlabel []string
	switch network {
	case "BSC":
		dexFactory = []string{"0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73", "0x0841BD0B734E4F5853f0dD8d7Ea041c241fb0Da6", "0x858E3312ed3A876947EA49d572A7C42DE08af7EE", "0x86407bEa2078ea5f5EB5A52B2caA963bC1F889Da"}
		label = []string{"Pancake", "ApeSwap", "Biswap", "BabySwap"}
		dexRouter = []string{"0x10ED43C718714eb63d5aA57B78B54704E256024E", "0xcF0feBd3f17CEf5b47b0cD257aCf6025c5BFf3b7", "0x3a6d8cA21D1CF76F653A67577FA0D27453350dD8", "0x8317c460C22A9958c27b4B6403b98d2Ef4E2ad32"}
		fiat = []string{"0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56", "0x55d398326f99059fF775485246999027B3197955", "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c", "0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d", "0x4DB5a66E937A9F4473fA95b1cAF1d1E1D62E29EA", "0x1AF3F329e8BE154074D8769D1FFa4eE058B1DBc3"} //
		fiatlabel = []string{"BUSD", "USDT", "WBNB", "USDC", "WETH", "DAI"}
	case "ETH":
		dexFactory = []string{"0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f", "0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac"}
		label = []string{"UniSwap", "SushiSwap"} //- UniSwap, SushiSwap
		dexRouter = []string{"0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D", "0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F"}
		fiat = []string{"0x4Fabb145d64652a948d72533023f6E7A623C7C53", "0xdAC17F958D2ee523a2206206994597C13D831ec7", "0x418D75f65a02b3D53B2418FB8E1fe493759c7605", "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48", "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", "0x6B175474E89094C44Da98b954EedeAC495271d0F"}
		fiatlabel = []string{"BUSD", "USDT", "WBNB", "USDC", "WETH", "DAI"} //BUSD, USDT, WBNB, USDC, WETH, DAI,
	}

	//fmt.Println(dexRouter, label, fiatlabel)

	for i, dexfactAddr := range dexFactory {
		pairInfo := getPair(fiat, fiatlabel, token, dexfactAddr, label[i], client, dexRouter[i])

		if pairInfo != "Empty" {
			pInf <- pairInfo
			break
		} else {
			pInf <- "Empty"
		}

	}
}
func getPair(fiatArray []string, fiatLabelArray []string, addressToken string, dexfactAddr string, label string, client ethclient.Client, router string) string {
	factory := common.HexToAddress(dexfactAddr)
	dead := "0x0000000000000000000000000000000000000000"
	addressDToken := common.HexToAddress(addressToken)
	instancePancakeFactory, err := pancakefactory.NewPancakeFactory(factory, &client)
	if err != nil {
		fmt.Println("Instance Error:", err)
	}
	var PairInfo string
	PairInfo = ""
	var wg sync.WaitGroup
	pairfound := make(chan string)
	for i, fiat := range fiatArray {
		wg.Add(1)
		addrDfiat := common.HexToAddress(fiat)

		pairAdd := func(addressDFiat common.Address, pairfound chan string) {
			defer wg.Done()
			pair, err := instancePancakeFactory.GetPair(&bind.CallOpts{}, addressDFiat, addressDToken)
			if err != nil {
				fmt.Print(err.Error())
			}
			x := string(pair.Hex())
			if x != dead {
				//===Get Liquidity ==
				var liquidty float64

				liqu := make(chan float64)
				wg.Add(1)
				go getLiquity(addrDfiat, pair, client, liqu, &wg)
				liquidty = <-liqu

				//====== Get Total Supply ==========
				var totalSuppy int64
				//totalSuppy = *big.NewInt(0)
				ttslp := make(chan int64)
				wg.Add(1)
				go getTotalSuppy(addressDToken, pair, client, ttslp, &wg)
				totalSuppy = <-ttslp

				//===Get Token Liquidity ==
				var tokenliquidty float64

				Tliqu := make(chan float64)
				wg.Add(1)
				go getLiquity(addressDToken, pair, client, Tliqu, &wg)
				tokenliquidty = <-Tliqu

				pairfound <- x + " " + label + " " + fiatLabelArray[i] + " " + fiat + " " + fmt.Sprintf("%f", liquidty) + " " + strconv.Itoa(int(totalSuppy)) + " " + fmt.Sprintf("%f", tokenliquidty) + " " + router
			} else {
				pairfound <- "Empty"
			}
		}

		go pairAdd(addrDfiat, pairfound)
		PairInfo = <-pairfound

		if PairInfo != "Empty" {
			return PairInfo

		}

	}
	wg.Wait()
	return "Empty"
}
func getLiquity(addrDfiat common.Address, pair common.Address, client ethclient.Client, liqu chan float64, wg *sync.WaitGroup) {
	defer wg.Done()
	erc20instance, err := erc20.NewERC20Token(addrDfiat, &client)
	if err != nil {
		fmt.Println("Erc Instance Error:", err)
	}
	decimal, err := erc20instance.Decimals(&bind.CallOpts{})
	if err != nil {
		fmt.Println("Decimal Error:", err)
	}
	liquidty, err := erc20instance.BalanceOf(&bind.CallOpts{}, pair)
	if err != nil {
		fmt.Println("Liquidity Error:", err)
	}
	valFunc := func() big.Float {

		if liquidty.Cmp(big.NewInt(0)) > 0 {
			return *(new(big.Float).Quo(big.NewFloat(0).SetInt(liquidty), big.NewFloat(0).SetInt(big.NewInt(int64(math.Pow(10, float64(decimal)))))))
		}
		return *big.NewFloat(0)
	}
	val := valFunc()
	res, _ := val.Float64()
	liqu <- res
}
func getTokenDecima(token common.Address, client ethclient.Client) uint8 {
	erc20instance, err := erc20.NewERC20Token(token, &client)
	if err != nil {
		fmt.Println("Erc Instance Error:", err)
	}
	decimal, err := erc20instance.Decimals(&bind.CallOpts{})
	if err != nil {
		fmt.Println("Decimal Error:", err)
	}
	return decimal
}
func getTotalSuppy(token common.Address, pair common.Address, client ethclient.Client, ttslp chan int64, wg *sync.WaitGroup) {
	defer wg.Done()
	erc20instance, err := erc20.NewERC20Token(token, &client)
	if err != nil {
		fmt.Println("Erc Instance Error:", err)
	}
	decimal, err := erc20instance.Decimals(&bind.CallOpts{})
	if err != nil {
		fmt.Println("Decimal Error:", err)
	}
	totals, err := erc20instance.TotalSupply(&bind.CallOpts{})
	if err != nil {
		fmt.Println("Liquidity Error:", err)
	}

	tt := big.NewInt(0).Div(totals, big.NewInt(int64(math.Pow(10, float64(decimal)))))
	ttslp <- tt.Int64()
}
func getAbi(token string, network string) string {
	for !limter.Allow() {
		time.Sleep(time.Millisecond * 1000)
		fmt.Println("Waiting for ", time.Millisecond*1000, "To Safu ", token)
	}
	var url string
	switch network {
	case "BSC":
		url = "https://api.bscscan.com/api?module=contract&action=getabi&address=" + token + "&apikey=41B2URZ35U5KTGBXN6HD1XWBBTMUHPZ57W"
	case "ETH":
		url = "https://api.etherscan.com/api?module=contract&action=getabi&address=" + token + "&apikey=ZFE87ZZFWMI821WJYBMJ9X48EKBBX9YG13"
	}
	var state bool
	state = true
	resp, err := http.Get(url)
	if err != nil {
		fmt.Printf("Error closing response body: %s\n", err.Error())
		state = false
	}
	if state {
		//defer resp.Body.Close()
		defer func() {
			if err := resp.Body.Close(); err != nil {
				// Handle the error
				state = false
				fmt.Printf("Error closing response body: %s\n", err.Error())
				time.Sleep(10 * time.Second)
			}
		}()

		//fmt.Println("=====ture")
		var data map[string]interface{}
		if err := json.NewDecoder(resp.Body).Decode(&data); err != nil {
			fmt.Println(err)
		}

		// Print the decoded data
		resultzz, ok := data["result"]
		if !ok {
			// handle error: "result" key not found in "data" map
		}

		switch vinter := resultzz.(type) {
		case string:
			//fmt.Println("======String======", vinter)
			return vinter
			// handle error: "result" value is a string, not a slice of interfaces
			//if _, ok := data["result"].([]interface{}); ok {
		case []interface{}:
			//var result map[string]interface{}
			return "[]"
			//bx, err := json.Marshal(vinter[0]) //(data["result"].([]interface{})[0])

		default:
			// handle error: "result" value is of an unexpected type
		}

		//open <- false
	}
	return ""

}

func getDeployedOwner(token string, network string) string {
	for !limter.Allow() {
		time.Sleep(time.Millisecond * 1000)
		fmt.Println("Waiting for ", time.Millisecond*1000, "To Safu ", token)
	}
	var url string
	switch network {
	case "BSC":
		url = "https://api.bscscan.com/api?module=account&action=txlist&address=" + token + "&startblock=0&endblock=99999999&page=1&offset=10&sort=asc&apikey=41B2URZ35U5KTGBXN6HD1XWBBTMUHPZ57W"
	case "ETH":
		url = "https://api.etherscan.com/api?module=account&action=txlist&address=" + token + "&startblock=0&endblock=99999999&page=1&offset=10&sort=asc&apikey=ZFE87ZZFWMI821WJYBMJ9X48EKBBX9YG13"
	}
	var state bool
	state = true
	resp, err := http.Get(url)
	if err != nil {
		fmt.Printf("Error closing response body: %s\n", err.Error())
		state = false
	}
	if state {
		//defer resp.Body.Close()
		defer func() {
			if err := resp.Body.Close(); err != nil {
				// Handle the error
				state = false
				fmt.Printf("Error closing response body: %s\n", err.Error())
				time.Sleep(10 * time.Second)
			}
		}()

		//fmt.Println("=====ture")
		var data map[string]interface{}
		if err := json.NewDecoder(resp.Body).Decode(&data); err != nil {
			fmt.Println(err)
		}

		// Print the decoded data
		resultzz, ok := data["result"]
		if !ok {
			// handle error: "result" key not found in "data" map
		}

		switch vinter := resultzz.(type) {
		case string:
			fmt.Println("======String======", vinter)

			// handle error: "result" value is a string, not a slice of interfaces
			//if _, ok := data["result"].([]interface{}); ok {
		case []interface{}:
			var result map[string]interface{}
			if len(vinter) > 0 {
				bx, err := json.Marshal(vinter[0]) //(data["result"].([]interface{})[0])
				if err != nil {
					fmt.Println(err)
				}
				if err := json.Unmarshal(bx, &result); err != nil {
					fmt.Println(err)
				}
				return (result["from"].(string))
			} else {
				return "0x.."
			}
		default:

		}

		//open <- false
	}
	return ""

}
func getLocked(pair string, locker string, label string, ctx context.Context, client ethclient.Client, wgx *sync.WaitGroup, lpLocked chan string) {
	defer wgx.Done()
	addrDpair := common.HexToAddress(pair)
	addrDLock := common.HexToAddress(locker)
	erc20instance, err := erc20.NewERC20Token(addrDpair, &client)
	if err != nil {
		fmt.Println("Erc Instance Error:", err)
	}
	decimal, err := erc20instance.Decimals(&bind.CallOpts{})
	if err != nil {
		fmt.Println("Decimal Error:", err)
	}
	liquidty, err := erc20instance.BalanceOf(&bind.CallOpts{}, addrDLock)
	if err != nil {
		fmt.Println("Liquidity Error:", err)
	}
	valFunc := func() big.Float {

		if liquidty.Cmp(big.NewInt(0)) > 0 {
			return *(new(big.Float).Quo(big.NewFloat(0).SetInt(liquidty), big.NewFloat(0).SetInt(big.NewInt(int64(math.Pow(10, float64(decimal)))))))
		}
		return *big.NewFloat(0)
	}
	totals, err := erc20instance.TotalSupply(&bind.CallOpts{})
	if err != nil {
		fmt.Println("Liquidity Error:", err)
	}
	tt := new(big.Float).Quo(big.NewFloat(0).SetInt(totals), big.NewFloat(0).SetInt(big.NewInt(int64(math.Pow(10, float64(decimal))))))
	val := valFunc()
	res, _ := val.Float64()
	xtt, _ := tt.Float64()
	ration := res / xtt
	//fmt.Println("===>The Ration", ration, totals, tt, res, decimal)
	if (ration * 100) > 0 {
		lpLocked <- fmt.Sprintf("%.2f", ration*100) + " " + label
	} else {
		lpLocked <- "Empty"
	}

}

func getCreationBlock(token string, network string) string {
	for !limter.Allow() {
		time.Sleep(time.Millisecond * 1000)
		fmt.Println("Waiting for ", time.Millisecond*1000, "To Safu ", token)
	}
	var url string
	switch network {
	case "BSC":
		url = "https://api.bscscan.com/api?module=contract&action=getcontractcreation&contractaddresses=" + token + "&apikey=41B2URZ35U5KTGBXN6HD1XWBBTMUHPZ57W"
	case "ETH":
		url = "https://api.etherscan.com/api?module=contract&action=getcontractcreation&contractaddresses=" + token + "&apikey=ZFE87ZZFWMI821WJYBMJ9X48EKBBX9YG13"
	}
	var state bool
	state = true
	resp, err := http.Get(url)
	if err != nil {
		fmt.Printf("Error closing response body: %s\n", err.Error())
		state = false
	}
	if state {
		//defer resp.Body.Close()
		defer func() {
			if err := resp.Body.Close(); err != nil {
				// Handle the error
				state = false
				fmt.Printf("Error closing response body: %s\n", err.Error())
				time.Sleep(10 * time.Second)
			}
		}()

		//fmt.Println("=====ture")
		var data map[string]interface{}
		if err := json.NewDecoder(resp.Body).Decode(&data); err != nil {
			fmt.Println(err)
		}

		// Print the decoded data
		resultzz, ok := data["result"]
		if !ok {
			// handle error: "result" key not found in "data" map
		}

		switch vinter := resultzz.(type) {
		case string:
			fmt.Println("======String======", vinter)

			// handle error: "result" value is a string, not a slice of interfaces
			//if _, ok := data["result"].([]interface{}); ok {
		case []interface{}:
			var result map[string]interface{}
			bx, err := json.Marshal(vinter[0]) //(data["result"].([]interface{})[0])
			if err != nil {
				fmt.Println(err)
			}
			if err := json.Unmarshal(bx, &result); err != nil {
				fmt.Println(err)
			}
			return result["txHash"].(string)

		default:

		}

		//open <- false
	}
	return ""

}
func getSourceCode(token string, network string) string {
	for !limter.Allow() {
		time.Sleep(time.Millisecond * 1000)
		fmt.Println("Waiting for ", time.Millisecond*1000, "To Safu ", token)
	}
	var url string
	switch network {
	case "BSC":
		url = "https://api.bscscan.com/api?module=contract&action=getsourcecode&address=" + token + "&apikey=41B2URZ35U5KTGBXN6HD1XWBBTMUHPZ57W"
	case "ETH":
		url = "https://api.etherscan.com/api?module=contract&action=getsourcecode&address=" + token + "&apikey=ZFE87ZZFWMI821WJYBMJ9X48EKBBX9YG13"
	}
	var state bool
	state = true
	resp, err := http.Get(url)
	if err != nil {
		fmt.Printf("Error closing response body: %s\n", err.Error())
		state = false
	}
	if state {
		//defer resp.Body.Close()
		defer func() {
			if err := resp.Body.Close(); err != nil {
				// Handle the error
				state = false
				fmt.Printf("Error closing response body: %s\n", err.Error())
				time.Sleep(10 * time.Second)
			}
		}()

		//fmt.Println("=====ture")
		var data map[string]interface{}
		if err := json.NewDecoder(resp.Body).Decode(&data); err != nil {
			fmt.Println(err)
		}

		// Print the decoded data
		resultzz, ok := data["result"]
		if !ok {
			// handle error: "result" key not found in "data" map
		}

		switch vinter := resultzz.(type) {
		case string:
			fmt.Println("======String======")
			// handle error: "result" value is a string, not a slice of interfaces
			//if _, ok := data["result"].([]interface{}); ok {
		case []interface{}:
			var result map[string]interface{}
			//fmt.Println("======Worked======")
			bx, err := json.Marshal(vinter[0]) //(data["result"].([]interface{})[0])
			if err != nil {
				fmt.Println(err)
			}
			if err := json.Unmarshal(bx, &result); err != nil {
				fmt.Println(err)
			}
			fmt.Println("Proxy", result["Proxy"])
			if len(result["SourceCode"].(string)) > 5 {
				if strings.Contains(result["SourceCode"].(string)[:5], "{{") {
					//fmt.Println("Report Soucre Code", result["SourceCode"].(string))
					var sourceCodeData map[string]interface{}
					jsonStr := result["SourceCode"].(string)
					cleanedData := strings.ReplaceAll(jsonStr, "{{", "{")
					cleanedData = strings.ReplaceAll(cleanedData, "}}", "}")
					err = json.Unmarshal([]byte(cleanedData), &sourceCodeData)
					if err != nil {
						fmt.Println("Error parsing SourceCode JSON:", err)
						//return
					}
					contentValue := sourceCodeData["sources"].(map[string]interface{})["token.sol"].(map[string]interface{})["content"].(string)
					//fmt.Println("Report Soucre Code", contentValue)
					return contentValue
				} else {
					return result["SourceCode"].(string)
				}
			} else {
				return "Not Verified"
			}
		default:
			// handle error: "result" value is of an unexpected type
		}

		//open <- false
	}
	return ""

}
func getTelegram(token string, network string) string {
	for !limter.Allow() {
		time.Sleep(time.Millisecond * 1000)
		fmt.Println("Waiting for ", time.Millisecond*1000, "To Safu ", token)
	}
	var url string
	switch network {
	case "BSC":
		url = "https://api.bscscan.com/api?module=contract&action=getsourcecode&address=" + token + "&apikey=41B2URZ35U5KTGBXN6HD1XWBBTMUHPZ57W"
	case "ETH":
		url = "https://api.etherscan.com/api?module=contract&action=getsourcecode&address=" + token + "&apikey=ZFE87ZZFWMI821WJYBMJ9X48EKBBX9YG13"
	}
	var state bool
	state = true
	resp, err := http.Get(url)
	if err != nil {
		fmt.Printf("Error closing response body: %s\n", err.Error())
		state = false
	}
	if state {
		//defer resp.Body.Close()
		defer func() {
			if err := resp.Body.Close(); err != nil {
				// Handle the error
				state = false
				fmt.Printf("Error closing response body: %s\n", err.Error())
				time.Sleep(10 * time.Second)
			}
		}()

		//fmt.Println("=====ture")
		var data map[string]interface{}
		if err := json.NewDecoder(resp.Body).Decode(&data); err != nil {
			fmt.Println(err)
		}

		// Print the decoded data
		resultzz, ok := data["result"]
		if !ok {
			// handle error: "result" key not found in "data" map
		}

		switch vinter := resultzz.(type) {
		case string:
			fmt.Println("======String======")
			// handle error: "result" value is a string, not a slice of interfaces
			//if _, ok := data["result"].([]interface{}); ok {
		case []interface{}:
			var result map[string]interface{}
			//fmt.Println("======Worked======")
			bx, err := json.Marshal(vinter[0]) //(data["result"].([]interface{})[0])
			if err != nil {
				fmt.Println(err)
			}
			if err := json.Unmarshal(bx, &result); err != nil {
				fmt.Println(err)
			}

			fmt.Println(result["Proxy"], len(data["result"].([]interface{})), "Is Token ("+token+") Verified", strings.Contains(result["SourceCode"].(string), "pragma solidity"), "TG:-", strings.Contains(result["SourceCode"].(string), "t.me/"))

			if strings.Contains(result["SourceCode"].(string), "pragma solidity") {
				if strings.Contains(result["SourceCode"].(string), "t.me/") {
					surcode := result["SourceCode"].(string)
					tgSt := strings.Index(surcode, "t.me/")
					tgTmp := surcode[tgSt:(tgSt + 50)]
					//fmt.Println("Telegram group", tgTmp)
					tgInx := func() int {
						if strings.Index(tgTmp, "\n") > -1 {
							return strings.Index(tgTmp, "\n")
						} else if strings.Index(tgTmp, "\r") > -1 {
							return strings.Index(tgTmp, "\r")
						} else if strings.Index(tgTmp, " ") > -1 {
							return strings.Index(tgTmp, " ")
						}

						return 0
					}

					tgUrl := strings.ReplaceAll(surcode[tgSt:(tgSt+tgInx())], "\r", "")
					//fmt.Println("Telegram group", tgUrl)

					fmt.Println("Telegram group", tgUrl)
					return tgUrl
				} else {
					fmt.Println("Telegram group None 😔")
					return "No TG Group Found"
				}
			}
		default:
			// handle error: "result" value is of an unexpected type
		}

		//open <- false
	}
	return ""

}
